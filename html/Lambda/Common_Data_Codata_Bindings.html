<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Common_Data_Codata_Bindings (Isabelle2018: August 2018)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Common_Data_Codata_Bindings</h1>

<span class="command">theory</span> <span class="name">Common_Data_Codata_Bindings</span><br/>
<span class="keyword">imports</span> <a href="Prelim.html"><span class="name">Prelim</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Common_Data_Codata_Bindings</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;../Prelim&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bound(a::&#39;a) &#8801; |UNIV :: &#39;a set|&quot;</span></span></span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The following are replaced by the concrete items defining 
the desired syntax: *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* typedecl (&#39;a,&#39;b,&#39;c,&#39;d) F   
consts map_F :: &quot;(&#39;a &#8658; &#39;a) &#8658; (&#39;b &#8658; &#39;b) &#8658; (&#39;c &#8658; &#39;c&#39;) &#8658; (&#39;d &#8658; &#39;d&#39;) &#8658; (&#39;a,&#39;b,&#39;c,&#39;d) F &#8658; (&#39;a,&#39;b,&#39;c&#39;,&#39;d&#39;)F&quot;
consts set1_F :: &quot;(&#39;a,&#39;b,&#39;c,&#39;d) F &#8658; &#39;a set&quot;
consts set2_F :: &quot;(&#39;a,&#39;b,&#39;c,&#39;d) F &#8658; &#39;b set&quot;
consts set3_F :: &quot;(&#39;a,&#39;b,&#39;c,&#39;d) F &#8658; &#39;c set&quot;
consts set4_F :: &quot;(&#39;a,&#39;b,&#39;c,&#39;d) F &#8658; &#39;d set&quot;
consts rrel_F :: &quot;(&#39;c &#8658; &#39;c&#39; &#8658; bool) &#8658; (&#39;d &#8658; &#39;d&#39; &#8658; bool) &#8658; (&#39;a,&#39;b,&#39;c,&#39;d) F &#8658; (&#39;a,&#39;b,&#39;c&#39;,&#39;d&#39;)F &#8658; bool&quot;
consts wit_F :: &quot;(&#39;a,&#39;b,&#39;c&#39;,&#39;d) F&quot;

typedecl bd_type_TT
consts bd_TT :: &quot;bd_type_TT rel&quot;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(****)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Syntax of untyped &#955;-calculus (Example 3 in the paper): *)</span></span></span></span></span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* A variant of &#39;a + &#39;b&#215;&#39;d + &#39;c&#215;&#39;c, but nicer to manage:   *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span>set1_F</span><span class="delimiter">:</span><span> </span><span class="tfree">&#39;a</span><span class="delimiter">,</span><span> </span><span>set2_F</span><span class="delimiter">:</span><span> </span><span class="tfree">&#39;b</span><span class="delimiter">,</span><span> </span><span>set3_F</span><span class="delimiter">:</span><span> </span><span class="tfree">&#39;c</span><span class="delimiter">,</span><span> </span><span>set4_F</span><span class="delimiter">:</span><span> </span><span class="tfree">&#39;d</span><span class="delimiter">)</span><span> </span><span>LIVE_F</span><span> </span><span class="delimiter">=</span><span> 
</span><span>   </span><span>C1</span><span> </span><span class="tfree">&#39;a</span><span> </span><span class="delimiter">|</span><span> </span><span>C2</span><span> </span><span class="tfree">&#39;b</span><span> </span><span class="tfree">&#39;d</span><span> </span><span class="delimiter">|</span><span> </span><span>C3</span><span> </span><span class="tfree">&#39;c</span><span> </span><span class="tfree">&#39;c</span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>map</span><span class="delimiter">:</span><span> </span><span>map_F</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wit_F &#8801; C1 any&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>bd_type_TT</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bd_TT</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;nat rel&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bd_TT &#8801; natLeq&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* AFTER THIS, GENERIC DEVELOPMENT 
(the same for any syntax matching the given MRBNF arity): *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">&#39;a</span><span class="delimiter">,</span><span class="tfree">&#39;b</span><span class="delimiter">,</span><span class="tfree">&#39;c</span><span class="delimiter">,</span><span class="tfree">&#39;d</span><span class="delimiter">)</span><span> </span><span>F</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a,&#39;b,&#39;c,&#39;d) LIVE_F&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rrel_F &#8801; rel_LIVE_F (=) (=)&quot;</span></span></span><span>  
</span><span> 
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>var_TT</span><span> </span><span class="delimiter">=</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>var_TT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bd_TT &#8804;o bound(any::&#39;a) &#8743; 
                                regularCard (bound(any::&#39;a))&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Possible instantiation: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>nat</span><span> </span><span class="delimiter">::</span><span> </span><span>var_TT</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>natLeq_Card_order</span><span> 
</span><span>stable_nat</span><span> </span><span>stable_regularCard</span><span> </span><span>bd_TT_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_set_finite</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;finite (set1_F x)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;finite (set2_F x)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;finite (set3_F x)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;finite (set4_F x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Verifying the MRBNF assumptions: *)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> 
</span><span>    </span><span>F_map_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F id id id id = id&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F_map_comp1</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; (u::&#39;a::var_TT&#8658;&#39;a) u&#39; (v::&#39;b::var_TT&#8658;&#39;b) v&#39; f f&#39; g g&#39;.
    |supp u| &lt;o bound(any::&#39;a) &#10233; |supp u&#39;| &lt;o bound(any::&#39;a) &#10233;
    bij v &#10233; |supp v| &lt;o bound(any::&#39;b) &#10233; bij v&#39; &#10233; |supp v&#39;| &lt;o bound(any::&#39;b) &#10233;
    map_F (u o u&#39;) (v o v&#39;) (f o f&#39;) (g o g&#39;) = map_F u v f g o map_F u&#39; v&#39; f&#39; g&#39;&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F_set1_map</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; (u::&#39;a::var_TT&#8658;&#39;a) (v::&#39;b::var_TT&#8658;&#39;b) f g b.
    |supp u| &lt;o bound(any::&#39;a) &#10233;
    bij v &#10233; |supp v| &lt;o bound(any::&#39;b) &#10233; set1_F (map_F u v f g b) = u ` set1_F b&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F_set2_map</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; (u::&#39;a::var_TT&#8658;&#39;a) (v::&#39;b::var_TT&#8658;&#39;b) f g b.
    |supp u| &lt;o bound(any::&#39;a) &#10233;
    bij v &#10233; |supp v| &lt;o bound(any::&#39;b) &#10233; set2_F (map_F u v f g b) = v ` set2_F b&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F_set3_map</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; (u::&#39;a::var_TT&#8658;&#39;a) (v::&#39;b::var_TT&#8658;&#39;b) f g b.
    |supp u| &lt;o bound(any::&#39;a) &#10233;
    bij v &#10233; |supp v| &lt;o bound(any::&#39;b) &#10233; set3_F (map_F u v f g b) = f ` set3_F b&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F_set4_map</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; (u::&#39;a::var_TT&#8658;&#39;a) (v::&#39;b::var_TT&#8658;&#39;b) f g b.
    |supp u| &lt;o bound(any::&#39;a) &#10233;
    bij v &#10233; |supp v| &lt;o bound(any::&#39;b) &#10233; set4_F (map_F u v f g b) = g ` set4_F b&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F_map_cong</span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; (u::&#39;a::var_TT&#8658;&#39;a) u&#39; (v::&#39;b::var_TT&#8658;&#39;b) v&#39; f f&#39; g g&#39; x.
    |supp u| &lt;o bound(any::&#39;a) &#10233; |supp u&#39;| &lt;o bound(any::&#39;a) &#10233;
    bij v &#10233; |supp v| &lt;o bound(any::&#39;b) &#10233; bij v&#39; &#10233; |supp v&#39;| &lt;o bound(any::&#39;b) &#10233;
    &#8704; a &#8712; set1_F x. u a = u&#39; a &#10233;
    &#8704; b &#8712; set2_F x. v b = v&#39; b &#10233;
    &#8704; c &#8712; set3_F x. f c = f&#39; c &#10233;
    &#8704; d &#8712; set4_F x. g d = g&#39; d &#10233;
    map_F u v f g x = map_F u&#39; v&#39; f&#39; g&#39; x&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bd_TT_card_order</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card_order bd_TT&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F_set1_bd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;b. |set1_F b| &lt;o bd_TT&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F_set2_bd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;b. |set2_F b| &lt;o bd_TT&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F_set3_bd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;b. |set3_F b| &lt;o bd_TT&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F_set4_bd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;b. |set4_F b| &lt;o bd_TT&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bd_TT_cinfinite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cinfinite bd_TT&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F_rel_comp_leq_</span><span class="delimiter">:</span><span>  
</span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; R R&#39; S S&#39;. rrel_F R S OO rrel_F R&#39; S&#39; &#8804; rrel_F (R OO R&#39;) (S OO S&#39;)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F_rel_map_set2_</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; (u::&#39;a::var_TT&#8658;&#39;a) (v::&#39;b::var_TT&#8658;&#39;b) R S x y. 
  |supp u| &lt;o bound(any::&#39;a) &#10233; bij v &#10233; |supp v| &lt;o bound(any::&#39;b) &#10233;  
  rrel_F R S (map_F u v id id x) y =
    (&#8707;z. set3_F z &#8838; {(x, y). R x y} &#8743;
         set4_F z &#8838; {(x, y). S x y} &#8743; map_F id id fst fst z = x &#8743; map_F u v snd snd z = y)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F_wit1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set3_F wit_F = {}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>F_wit2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set4_F wit_F = {}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>LIVE_F.map_id0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>LIVE_F.map_comp0</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LIVE_F.set_map</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LIVE_F.set_map</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LIVE_F.set_map</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>LIVE_F.set_map</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>LIVE_F.map_cong</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bd_TT_def</span><span> </span><span>F_set_finite</span><span> </span><span>finite_iff_ordLess_natLeq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span>cardSuc_ordLeq_ordLess</span><span> </span><span>LIVE_F.set_bd</span><span> </span><span>LIVE_F.bd_card_order</span><span> 
</span><span>  </span><span>LIVE_F.bd_cinfinite</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rrel_F_def</span><span>  
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>preorder_class.eq_refl</span><span class="delimiter">[</span><span>OF</span><span> 
</span><span>LIVE_F.rel_compp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(=)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(=)&quot;</span></span></span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(=)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(=)&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>R</span><span> </span><span>S</span><span> </span><span>x</span><span> </span><span>y</span><span>  
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LIVE_F.rel_map</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>LIVE_F.in_rel</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>z</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F fst fst id id z&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>LIVE_F.set_map</span><span> </span><span>LIVE_F.map_comp</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>LIVE_F.map_cong</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>z</span><span>   
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F (&#955;a. (a,u a)) (&#955;a. (a,v a)) id id z&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>LIVE_F.set_map</span><span> </span><span>LIVE_F.map_comp</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>LIVE_F.map_cong</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wit_F_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bd_TT_Card_order</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Card_order bd_TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bd_TT_card_order</span><span> </span><span>card_order_on_Card_order</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>var_TT</span><span class="delimiter">)</span><span> </span><span>UNIV_cinfinite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cinfinite (bound(any::&#39;a))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bd_TT_cinfinite</span><span> </span><span>cinfinite_mono</span><span> </span><span>var_TT</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* CARDINAL SETUP FOR THE TO-BE-DEFINED TYPE TT OF (QUOTIENTED) TERMS *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* For datatypes, we care about backwards compatibility with the finitary case: *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* For codatatypes, we need a larger bound: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bbd_TT</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bbd_TT &#8801; cardSuc bd_TT&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>vvar_TT</span><span> </span><span class="delimiter">=</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>vvar_TT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bbd_TT &#8804;o bound(any::&#39;a) &#8743; regularCard (bound(any::&#39;a))&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Everything we prove for a type of class var_TT will automnatically be inheritted 
to vvar_TT: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subclass</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>vvar_TT</span><span class="delimiter">)</span><span> </span><span>var_TT</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bbd_TT_def</span><span> </span><span>bd_TT_card_order</span><span> </span><span>cardSuc_ordLess_ordLeq</span><span> </span><span>card_of_card_order_on</span><span>
</span><span>    </span><span>card_order_on_Card_order</span><span> </span><span>vvar_TT</span><span> </span><span>ordLess_imp_ordLeq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* In addition, we have the property which var_TT avoided for backwards compatibility, 
but is crucial for codatatypes: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>natLeq_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;natLeq &lt;o bound(any::&#39;a::vvar_TT)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;natLeq &#8804;o bd_TT&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>natLeq_ordLeq_cinfinite</span><span> </span><span>bd_TT_cinfinite</span><span> </span><span>bd_TT_Card_order</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;natLeq &lt;o bbd_TT&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bbd_TT_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bd_TT_Card_order</span><span> </span><span>natLeq_Card_order</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span class="string"><span class="delete"><span class="delete">&quot;bbd_TT &#8804;o |UNIV::&#39;a set|&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vvar_TT</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*    *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>bound_Card_order</span><span> </span><span class="delimiter">=</span><span> </span><span>card_of_Card_order</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;UNIV::(&#39;a::var_TT)set&quot;</span></span></span><span class="delimiter">]</span><span>    
</span><span>    
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>bound_card_order</span><span> </span><span class="delimiter">=</span><span> </span><span>card_of_card_order_on</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;UNIV::(&#39;a::var_TT)set&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bound_regularCard</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;regularCard (bound(any::&#39;a::var_TT))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>var_TT</span><span class="delimiter">)</span><span> 
</span><span>    
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>bound_cinfinite</span><span> </span><span class="delimiter">=</span><span> </span><span>var_TT_class.UNIV_cinfinite</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span>wit_vvar_TT</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Field bbd_TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bbd_TT_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Field_cardSuc_not_empty</span><span> </span><span>bd_TT_Card_order</span><span> </span><span>ex_in_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wit_var_TT_ordIso_bd_TT_type_set</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bbd_TT =o |UNIV:: wit_vvar_TT set|&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|UNIV:: wit_vvar_TT set| =o |Field bbd_TT|&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Abs_wit_vvar_TT_inverse</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>card_of_ordIsoI</span><span class="delimiter">[</span><span>of</span><span> </span><span>Rep_wit_vvar_TT</span><span class="delimiter">]</span><span class="delimiter">)</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Rep_wit_vvar_TT_inject</span><span> 
</span><span>       </span><span>Rep_wit_vvar_TT</span><span> </span><span>bij_betw_def</span><span> </span><span>inj_on_def</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bbd_TT_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_order_iff_ordIso_card_of</span><span> </span><span>bd_TT_Card_order</span><span> </span><span>cardSuc_Card_order</span><span> </span><span>ordIso_symmetric</span><span> </span><span>ordIso_transitive</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bbd_TT_ordLeq_wit_vvar_TT</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bbd_TT &#8804;o |UNIV:: wit_vvar_TT set|&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordIso_iff_ordLeq</span><span> </span><span>wit_var_TT_ordIso_bd_TT_type_set</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>regularCard_wit_vvar_TT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;regularCard |UNIV:: wit_vvar_TT set|&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cinfinite_cardSuc</span><span> </span><span>Cnotzero_UNIV</span><span> </span><span>bbd_TT_def</span><span> </span><span>bbd_TT_ordLeq_wit_vvar_TT</span><span> </span><span>bd_TT_Card_order</span><span>
</span><span>    </span><span>bd_TT_cinfinite</span><span> </span><span>cinfinite_def</span><span> </span><span>cinfinite_mono</span><span> </span><span>infinite_cardSuc_regularCard</span><span> </span><span>regularCard_ordIso</span><span>
</span><span>    </span><span>wit_var_TT_ordIso_bd_TT_type_set</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Need to instantiate the class, else datatype construction will fail: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>wit_vvar_TT</span><span> </span><span class="delimiter">::</span><span> </span><span>vvar_TT</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span class="delimiter">:</span><span> </span><span>regularCard_wit_vvar_TT</span><span> </span><span>bbd_TT_ordLeq_wit_vvar_TT</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>var_TT_infinite</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;infinite (UNIV :: (&#39;a :: var_TT) set)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bound_cinfinite</span><span> </span><span>Cnotzero_UNIV</span><span> </span><span>cardSuc_finite</span><span> </span><span>card_of_cardSuc_finite</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cinfinite_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>emp_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|{}| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_of_empty4</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set1_F_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|set1_F x| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_set1_bd</span><span> </span><span>ordLess_ordLeq_trans</span><span> </span><span>var_TT</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set2_F_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|set2_F x| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_set2_bd</span><span> </span><span>ordLess_ordLeq_trans</span><span> </span><span>var_TT</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set3_F_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|set3_F x| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_set3_bd</span><span> </span><span>ordLess_ordLeq_trans</span><span> </span><span>var_TT</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set4_F_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|set4_F x| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_set4_bd</span><span> </span><span>ordLess_ordLeq_trans</span><span> </span><span>var_TT</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>singl_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|{a}| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_ordLess_infinite</span><span> </span><span>var_TT_class.UNIV_cinfinite</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>cinfinite_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Un_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|A1| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|A2| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|A1 &#8746; A2| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>card_of_Un_ordLess_infinite</span><span> </span><span>var_TT_class.UNIV_cinfinite</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>cinfinite_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>UNION_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|I| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;i. i &#8712; I &#10233; |A i| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|&#8899;i&#8712;I. A i| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>bound_Card_order</span><span> </span><span>bound_cinfinite</span><span> </span><span>bound_regularCard</span><span> </span><span>regularCard_UNION</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>imsupp_supp_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;|imsupp g| &lt;o bound(any::&#39;a::var_TT) &#10231; |supp g| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_bound</span><span> </span><span>card_of_image</span><span> </span><span>imsupp_def</span><span> </span><span>ordLeq_ordLess_trans</span><span> </span><span>supp_ordleq_imsupp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supp_id_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp id| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>emp_bound</span><span> </span><span>supp_id</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supp_id_upd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp (id(a := a&#39;))| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a = a&#39;&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>singl_bound</span><span> </span><span>emp_bound</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supp_inv_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij f&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp f| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp (inv f)| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>supp_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>b</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span> </span><span>card_of_image</span><span> </span><span>ordLeq_ordLess_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supp_comp_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp g| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp f| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp (g o f)| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Un_bound</span><span> </span><span>assms</span><span> </span><span>card_of_mono1</span><span> </span><span>ordLeq_ordLess_trans</span><span> </span><span>supp_o</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supp_imsupp_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp f| &lt;o bound(any::&#39;a::var_TT) &#10233; |imsupp f| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_supp_bound</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_map_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span> </span><span>v&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span>R&#39;</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u&#39;| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v&#39;| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F (u o u&#39;) (v o v&#39;) (f o f&#39;) (g o g&#39;) x = map_F u v f g (map_F u&#39; v&#39; f&#39; g&#39; x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>F_map_comp1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_rel_map_</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>  
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rrel_F R S x y&quot;</span></span></span><span>   
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rrel_F R S (map_F u v id id x) (map_F u v id id y)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>F_rel_map_set2_</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span> </span><span>v</span><span class="delimiter">]</span><span>
</span><span>  </span><span>F_rel_map_set2_</span><span class="delimiter">[</span><span>OF</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>R</span><span> </span><span>S</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>F_map_id</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>z</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Verifying the old axiomatization: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rel_F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a :: var_TT &#8658; &#39;a) &#8658; (&#39;b :: var_TT &#8658; &#39;b) &#8658; 
 (&#39;c &#8658; &#39;c&#39; &#8658; bool) &#8658; (&#39;d &#8658; &#39;d&#39; &#8658; bool) &#8658; (&#39;a,&#39;b,&#39;c,&#39;d) F &#8658; (&#39;a,&#39;b,&#39;c&#39;,&#39;d&#39;)F &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F u v R S &#8801; &#955; x x&#39;. rrel_F R S (map_F u v id id x) x&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_rel_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F id id (=) (=) = (=)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_F_def</span><span> </span><span>fun_eq_iff</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_map_set2_</span><span> </span><span>supp_id_bound</span><span> </span><span>OO_Grp_alt</span><span> </span><span>bij_id</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span>
</span><span>    </span><span>F_set3_map</span><span> </span><span>F_set4_map</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>o_def</span><span> </span><span>id_apply</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>F_map_cong</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F id id (&#955;x. (x, x)) (&#955;x. (x, x)) _&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>F_map_id</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fun_cong</span><span class="delimiter">]</span><span> </span><span>id_apply</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_rel_comp_leq</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span>u&#39;</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span> </span><span>v&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span>R&#39;</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u&#39;| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v&#39;| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F u v R S OO rel_F u&#39; v&#39; R&#39; S&#39; &#8804; rel_F (u&#39; o u) (v&#39; o v) (R OO R&#39;) (S OO S&#39;)&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_F_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_rel_comp_leq_</span><span class="delimiter">[</span><span>of</span><span> </span><span>R</span><span> </span><span>S</span><span> </span><span>R&#39;</span><span> </span><span>S&#39;</span><span class="delimiter">]</span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_rel_map_</span><span class="delimiter">[</span><span>of</span><span> </span><span>u&#39;</span><span> </span><span>v&#39;</span><span> </span><span>R</span><span> </span><span>S</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F u v id id _&quot;</span></span></span><span> </span><span>_</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>predicate2D</span><span class="delimiter">)</span><span> 
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_rel_map_set2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span>S</span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F u v R S x y &#10231;
   (&#8707;z. set3_F z &#8838; {(x, y). R x y} &#8743; set4_F z &#8838; {(x, y). S x y} &#8743; 
     map_F id id fst fst z = x &#8743; map_F u v snd snd z = y)&quot;</span></span></span><span>  
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_F_def</span><span> </span><span>F_rel_map_set2_</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>  
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* SETUP FOR F *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>F_set_map</span><span> </span><span class="delimiter">=</span><span> </span><span>F_set1_map</span><span> </span><span>F_set2_map</span><span> </span><span>F_set3_map</span><span> </span><span>F_set4_map</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Moved above, since needed for verifying the old axiomatization: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>F_map_comp</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_rel_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span> </span><span>v&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span>R&#39;</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u&#39;| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v&#39;| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F (u&#39; o u) (v&#39; o v) (R OO R&#39;) (S OO S&#39;) = rel_F u v R S OO rel_F u&#39; v&#39; R&#39; S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>predicate2I</span><span> </span><span>F_rel_comp_leq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_map_set2</span><span> </span><span>assms</span><span> </span><span>relcompp_apply</span><span> </span><span>supp_comp_bound</span><span> </span><span>bij_comp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>4</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span> </span><span>supp_comp_bound</span><span> </span><span>bij_id</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>assms</span><span> </span><span>o_id</span><span> </span><span>id_o</span><span>
</span><span>        </span><span>o_apply</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>bij_comp</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>someI2_ex</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;b. R _ b &#8743; R&#39; b _&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;b. R _ b&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>someI2_ex</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;b. S _ b &#8743; S&#39; b _&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;b. S _ b&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>someI2_ex</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;b. R _ b &#8743; R&#39; b _&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;b. R&#39; b _&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>someI2_ex</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;b. S _ b &#8743; S&#39; b _&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;b. S&#39; b _&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F u v (&#955;(x, y). (SOME w. R x w &#8743; R&#39; w y, y)) (&#955;(x, y). (SOME w. S x w &#8743; S&#39; w y, y)) z&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F id id (&#955;(x, y). (x, SOME w. R x w &#8743; R&#39; w y)) (&#955;(x, y). (x, SOME w. S x w &#8743; S&#39; w y)) z&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>F_map_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_rel_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span>R&#39;</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>le</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;R &#8804; R&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S &#8804; S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F u v R S &#8804; rel_F u v R&#39; S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>F_rel_map_set2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bd</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_rel_Grp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span>g</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F u v (Grp f) (Grp g) = Grp (map_F u v f g)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>3</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_map_set2</span><span> </span><span>fun_eq_iff</span><span> </span><span>Grp_def</span><span> </span><span>assms</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>o_id</span><span>
</span><span>    </span><span>o_apply</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>F_set_map</span><span> </span><span>id_apply</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>F_map_cong</span><span>  </span><span>trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>F_map_cong</span><span> </span><span>fun_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>F_map_id</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>id_apply</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F id id (&#955;a. (a, f a)) (&#955;a. (a, g a)) _&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_rel_conversep</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span>S</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F (inv u) (inv v) (R&#175;&#175;) (S&#175;&#175;) = (rel_F u v R S)&#175;&#175;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_map_set2</span><span> </span><span>assms</span><span> </span><span>fun_eq_iff</span><span> </span><span>supp_inv_bound</span><span> </span><span>bij_imp_bij_inv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_map_set2</span><span> </span><span>assms</span><span> </span><span>fun_eq_iff</span><span> </span><span>supp_inv_bound</span><span> </span><span>bij_imp_bij_inv</span><span>
</span><span>      </span><span>F_set_map</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>id_o</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>o_apply</span><span>
</span><span>      </span><span>supp_comp_bound</span><span> </span><span>bij_comp</span><span> </span><span>id_apply</span><span> </span><span>inv_simp2</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F (inv u) (inv v) (&#955;(a, b). (b, a))  (&#955;(a, b). (b, a)) z&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>F_map_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_map_set2</span><span> </span><span>assms</span><span> </span><span>fun_eq_iff</span><span> </span><span>supp_inv_bound</span><span> </span><span>bij_imp_bij_inv</span><span>
</span><span>      </span><span>F_set_map</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>id_o</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span>o_apply</span><span>
</span><span>      </span><span>supp_comp_bound</span><span> </span><span>bij_comp</span><span> </span><span>id_apply</span><span> </span><span>inv_simp1</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F u v (&#955;(a, b). (b, a))  (&#955;(a, b). (b, a)) z&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>F_map_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_rel_map_left</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span> </span><span>v&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span>f</span><span> </span><span>S</span><span> </span><span>g</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u&#39;| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v&#39;| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F u v R S (map_F u&#39; v&#39; f g b) b&#39; =
       rel_F (u o u&#39;) (v o v&#39;) (Grp f OO R) (Grp g OO S) b b&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_comp</span><span> </span><span>assms</span><span> </span><span>F_rel_Grp</span><span> </span><span>relcompp_apply</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;x. _ x &#8743; _ x&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>conjI</span><span class="delimiter">]</span><span> </span><span>GrpI</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>GrpE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_rel_map_right</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span> </span><span>v&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span>f</span><span> </span><span>S</span><span> </span><span>g</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u&#39;| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v&#39;| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F u&#39; v&#39; R S b b&#39; &#10233;
       rel_F (u o u&#39;) (v o v&#39;) (R OO Grp f) (S OO Grp g) b (map_F u v f g b&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_comp</span><span> </span><span>assms</span><span> </span><span>F_rel_Grp</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>GrpI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_rel_map_right_bij</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span> </span><span>v&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span>f</span><span> </span><span>S</span><span> </span><span>g</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u&#39;| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v&#39;| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F u v R S b (map_F u&#39; v&#39; f g b&#39;) =
       rel_F (inv u&#39; o u) (inv v&#39; o v) (R OO conversep (Grp f)) (S OO conversep (Grp g)) b b&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_comp</span><span> </span><span>assms</span><span> </span><span>F_rel_Grp</span><span> </span><span>supp_inv_bound</span><span> </span><span>bij_imp_bij_inv</span><span>
</span><span>    </span><span>relcompp_apply</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>inv_o_simp2</span><span> </span><span>F_rel_conversep</span><span>
</span><span>    </span><span>conversep_iff</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>GrpI</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>GrpE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>F_rel_map</span><span> </span><span class="delimiter">=</span><span> </span><span>F_rel_map_left</span><span> </span><span>F_rel_map_right</span><span> </span><span>F_rel_map_right_bij</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_F_transfer</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;rel_fun (eq_onp (&#955; u::&#39;a::var_TT&#8658;&#39;a. |supp u| &lt;o bound(any::&#39;a)))
    (rel_fun (eq_onp (&#955; v::&#39;b::var_TT&#8658;&#39;b. bij v &#8743; |supp v| &lt;o bound(any::&#39;b)))
      (rel_fun (rel_fun R R&#39;) (rel_fun (rel_fun S S&#39;) (rel_fun (rel_F id id R S) (rel_F id id R&#39; S&#39;))))) map_F map_F&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_fun_def</span><span> </span><span>eq_onp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>3</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_map_left</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>id_o</span><span> </span><span>relcompp_apply</span><span> </span><span>Grp_def</span><span>
</span><span>    </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>predicate2D</span><span class="delimiter">[</span><span>OF</span><span> </span><span>F_rel_mono</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>F_rel_map_right</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>id</span><span> </span><span>_</span><span> </span><span>id</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>o_id</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>6</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_F_transfer</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;rel_fun (eq_onp (&#955; u::&#39;a::var_TT&#8658;&#39;a. |supp u| &lt;o bound(any::&#39;a)))
    (rel_fun (eq_onp (&#955; v::&#39;b::var_TT&#8658;&#39;b. bij v &#8743; |supp v| &lt;o bound(any::&#39;b)))
      (rel_fun (rel_fun R (rel_fun R&#39; (=))) (rel_fun (rel_fun S (rel_fun S&#39; (=))) (rel_fun (rel_F id id R S) (rel_fun (rel_F id id R&#39; S&#39;) (=)))))) rel_F rel_F&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_fun_def</span><span> </span><span>eq_onp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>_</span><span> </span><span>u</span><span> </span><span>_</span><span> </span><span>v</span><span> </span><span>P</span><span> </span><span>P&#39;</span><span> </span><span>Q</span><span> </span><span>Q&#39;</span><span> </span><span>b</span><span> </span><span>a</span><span> </span><span>c</span><span> </span><span>d</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>F_rel_mono</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>F_rel_comp_leq</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>id</span><span> </span><span>_</span><span> </span><span>id</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>6</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>relcomppI</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>id_o</span><span class="delimiter">,</span><span> </span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">;</span><span>
</span><span>        </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>3</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>F_rel_mono</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>F_rel_comp_leq</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>id</span><span> </span><span>_</span><span> </span><span>id</span><span> </span><span>_</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>6</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>relcomppI</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>o_id</span><span class="delimiter">,</span><span> </span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">;</span><span>
</span><span>        </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>3</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>F_rel_conversep</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2_eqD</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>conversep_iff</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>id</span><span> </span><span>id</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>inv_id</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span class="delimiter">;</span><span>
</span><span>        </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>_</span><span> </span><span>u</span><span> </span><span>_</span><span> </span><span>v</span><span> </span><span>P</span><span> </span><span>P&#39;</span><span> </span><span>Q</span><span> </span><span>Q&#39;</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>d</span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>F_rel_mono</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>F_rel_comp_leq</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>id</span><span> </span><span>_</span><span> </span><span>id</span><span> </span><span>_</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>6</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>relcomppI</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>o_id</span><span class="delimiter">]</span><span class="delimiter">;</span><span>
</span><span>        </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>F_rel_mono</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>F_rel_comp_leq</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>id</span><span> </span><span>_</span><span> </span><span>id</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>6</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>relcomppI</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>id_o</span><span class="delimiter">]</span><span class="delimiter">;</span><span>
</span><span>        </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>F_rel_conversep</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2_eqD</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>conversep_iff</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>id</span><span> </span><span>id</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>inv_id</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span class="delimiter">;</span><span>
</span><span>        </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* thm F.bd_card_order *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">bnf</span></span><span> </span><span>F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::var_TT,&#39;b::var_TT,&#39;c,&#39;d) F&quot;</span></span></span><span>
</span><span>  </span><span>map</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F id id :: _ &#8658; _ &#8658; (&#39;a::var_TT,&#39;b::var_TT,&#39;c,&#39;d) F &#8658; _&quot;</span></span></span><span>
</span><span>  </span><span>sets</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set3_F :: (&#39;a::var_TT,&#39;b::var_TT,&#39;c,&#39;d) F &#8658; _&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set4_F :: (&#39;a::var_TT,&#39;b::var_TT,&#39;c,&#39;d) F &#8658; _&quot;</span></span></span><span>
</span><span>  </span><span>bd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bd_TT&quot;</span></span></span><span>  </span><span>wits</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wit_F :: (&#39;a::var_TT,&#39;b::var_TT,&#39;c,&#39;d) F&quot;</span></span></span><span>
</span><span>  </span><span>rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F id id  :: _ &#8658; _ &#8658; (&#39;a::var_TT,&#39;b::var_TT,&#39;c,&#39;d) F &#8658; _ &#8658; _&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>bd_TT_cinfinite</span><span> </span><span>bd_TT_card_order</span><span>
</span><span>      </span><span>F_set_map</span><span class="delimiter">[</span><span>of</span><span> </span><span>id</span><span class="delimiter">]</span><span> </span><span>F_rel_comp</span><span class="delimiter">[</span><span>of</span><span> </span><span>id</span><span> </span><span>_</span><span> </span><span>id</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>F_rel_map_set2</span><span class="delimiter">[</span><span>of</span><span> </span><span>id</span><span> </span><span>id</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>      </span><span>fun_eq_iff</span><span> </span><span>F_set3_bd</span><span> </span><span>F_set4_bd</span><span> </span><span>ordLess_imp_ordLeq</span><span> </span><span>F_wit1</span><span> </span><span>F_wit2</span><span> </span><span>F_map_id</span><span>
</span><span>      </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>o_apply</span><span> </span><span>o_id</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>F_map_cong</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_rel_flip</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span>S</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F (inv u) (inv v) (conversep R) (conversep S) b b&#39; &#10231; rel_F u v R S b&#39; b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_rel_conversep</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>R</span><span> </span><span>S</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_set_transfer</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span>S</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span>F_set1_transfer</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_fun (rel_F u v R S) (Grp (image u)) set1_F set1_F&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>F_set2_transfer</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_fun (rel_F u v R S) (Grp (image v)) set2_F set2_F&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>F_set3_transfer</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_fun (rel_F u v R S) (rel_set R) set3_F set3_F&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>F_set4_transfer</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_fun (rel_F u v R S) (rel_set S) set4_F set4_F&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_fun_def</span><span> </span><span>rel_set_def</span><span> </span><span>Bex_def</span><span> </span><span>F_rel_map_set2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>Grp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>4</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>assms</span><span> </span><span>id_apply</span><span> </span><span>image_id</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_rel_mono_strong0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span> </span><span>v&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span>R&#39;</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>uv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u&#39;| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v&#39;| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F u v R S x y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>set1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;a&#8712;set1_F x. u a = u&#39; a&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>set2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;a&#8712;set2_F x. v a = v&#39; a&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>set3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;c1&#8712;set3_F x. &#8704;c2&#8712;set3_F y. R c1 c2 &#10230; R&#39; c1 c2&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>set4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;d1&#8712;set4_F x. &#8704;d2&#8712;set4_F y. S d1 d2 &#10230; S&#39; d1 d2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F u&#39; v&#39; R&#39; S&#39; x y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rel</span><span> </span><span>set1</span><span> </span><span>set2</span><span> </span><span>set3</span><span> </span><span>set4</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_map_set2</span><span> </span><span>uv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>uv</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>image_id</span><span> </span><span>id_apply</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>z</span><span class="delimiter">]</span><span> </span><span>F_map_cong</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_rel_mono_strong1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT&#8658;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::var_TT&#8658;&#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span>R&#39;</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;b)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F u v R S x y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>set3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;c1&#8712;set3_F x. &#8704;c2&#8712;set3_F y. R c1 c2 &#10230; R&#39; c1 c2&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>set4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;d1&#8712;set4_F x. &#8704;d2&#8712;set4_F y. S d1 d2 &#10230; S&#39; d1 d2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F u v R&#39; S&#39; x y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>F_rel_mono_strong0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>v</span><span> </span><span>rel</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>set3</span><span> </span><span>set4</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Some transfer setup  *)</span></span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rel_F_id</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;c &#8658; &#39;c&#39; &#8658; bool) &#8658; (&#39;d &#8658; &#39;d&#39; &#8658; bool) &#8658; (&#39;a::var_TT, &#39;b::var_TT, &#39;c, &#39;d) F &#8658; (&#39;a, &#39;b, &#39;c&#39;, &#39;d&#39;) F &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F_id = rel_F id id&quot;</span></span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>left_total_rel_F_id</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;left_total R &#10233; left_total S &#10233; left_total (rel_F_id R S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>left_total_alt_def</span><span> </span><span>rel_F_id_def</span><span> </span><span>F.rel_conversep</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span>F.rel_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>F.rel_compp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>  
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>F.rel_mono</span><span class="delimiter">)</span><span>  
</span><span>   
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>right_total_rel_F_id</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;right_total R &#10233; right_total S &#10233; right_total (rel_F_id R S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>right_total_alt_def</span><span> </span><span>rel_F_id_def</span><span> </span><span>F.rel_conversep</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span>F.rel_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>F.rel_compp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>F.rel_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bi_total_rel_F_id</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bi_total R &#10233; bi_total S &#10233; bi_total (rel_F_id R S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bi_total_alt_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>left_total_rel_F_id</span><span> </span><span>right_total_rel_F_id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>F.map_transfer</span><span class="delimiter">[</span><span>folded</span><span> </span><span>rel_F_id_def</span><span class="delimiter">,</span><span> </span><span>transfer_rule</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>F.set_transfer</span><span class="delimiter">[</span><span>folded</span><span> </span><span>rel_F_id_def</span><span class="delimiter">,</span><span> </span><span>transfer_rule</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>F_set1_transfer</span><span class="delimiter">[</span><span>OF</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>image_id</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>rel_F_id_def</span><span> </span><span>eq_alt</span><span class="delimiter">,</span><span> </span><span>transfer_rule</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>F_set2_transfer</span><span class="delimiter">[</span><span>OF</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>image_id</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>rel_F_id_def</span><span> </span><span>eq_alt</span><span class="delimiter">,</span><span> </span><span>transfer_rule</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ``as small support&#39;&#39; cast operator *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>asSS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::var_TT &#8658; &#39;a) &#8658; &#39;a &#8658; &#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;asSS f &#8801; if |supp f| &lt;o bound(any::&#39;a) then f else id&quot;</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>

</div>
</body>
</html>
