<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Datatype_Recursion_Template (Isabelle2018: August 2018)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Datatype_Recursion_Template</h1>

<span class="command">theory</span> <span class="name">Datatype_Recursion_Template</span><br/>
<span class="keyword">imports</span> <a href="More_Datatype_Bindings.html"><span class="name">More_Datatype_Bindings</span></a> <a href="Template.html"><span class="name">Template</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Datatype_Recursion_Template</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>More_Datatype_Bindings</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;../Template&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Term-like structures: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>termLikeStr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;a::var_TT &#8658; &#39;a) &#8658; &#39;c &#8658; &#39;c) &#8658; (&#39;c &#8658; &#39;a set) &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;termLikeStr swp fvars &#8801;
  swp id = id &#8743;
  (&#8704; u v. bij u &#8743; |supp u| &lt;o bound (any::&#39;a) &#8743; bij v &#8743; |supp v| &lt;o bound (any::&#39;a)
      &#10230; swp (u o v) = swp u o swp v) &#8743;
  (&#8704; u c. bij u &#8743; |supp u| &lt;o bound (any::&#39;a) &#8743;
      (&#8704; a. a &#8712; fvars c &#10230; u a = a) &#10230; swp u c = c) &#8743;
  (&#8704; u c a. bij u &#8743; |supp u| &lt;o bound (any::&#39;a)
     &#10230; (u a &#8712; fvars (swp u c) &#10231; a &#8712; fvars c))&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Extended term-like structures (needed for full-fledged recursion): *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>termLikeStrC</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;a::var_TT &#8658; &#39;a) &#8658; &#39;a TT &#8658; &#39;c &#8658; &#39;c) &#8658; (&#39;a TT &#8658; &#39;c &#8658; &#39;a set) &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;termLikeStrC mp fvars &#8801;
  (&#8704; t. mp id t = id) &#8743;
  (&#8704; u v t. bij u &#8743; |supp u| &lt;o bound (any::&#39;a) &#8743; bij v &#8743; |supp v| &lt;o bound (any::&#39;a)
    &#10230; mp (u o v) t = mp u t o mp v t) &#8743;
  (&#8704; u c t. bij u &#8743; |supp u| &lt;o bound (any::&#39;a) &#8743;
     (&#8704; a. a &#8712; fvars t c &#10230; u a = a) &#10230; mp u t c = c) &#8743;
  (&#8704; u c a t. bij u &#8743; |supp u| &lt;o bound (any::&#39;a) &#10230;
     (u a &#8712; fvars (map_TT u t) (mp u t c) &#10231; a &#8712; fvars t c))&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Lifting of the map operators to functions involving quotiented terms -- just a useful notation *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mmapfn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;a::var_TT &#8658; &#39;a) &#8658; &#39;c &#8658; &#39;c) &#8658; ((&#39;a &#8658; &#39;a) &#8658; &#39;a TT &#8658; &#39;d &#8658; &#39;d) &#8658;
 (&#39;a &#8658; &#39;a) &#8658; &#39;a TT &#8658; (&#39;c &#8658; &#39;d) &#8658; (&#39;c &#8658; &#39;d)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mmapfn swp1 swp2 &#8801; &#955; u t cd c. swp2 u t (cd (swp1 (inv u) c))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">template</span></span><span> </span><span>REC</span><span> </span><span class="delimiter">=</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The model and parameter types: *)</span></span></span></span></span><span>
</span><span>   </span><span class="tfree">&#39;a</span><span class="delimiter">::</span><span>var_TT</span><span> </span><span>C</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="tfree">&#39;a</span><span class="delimiter">::</span><span>var_TT</span><span> </span><span>P</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Some variables to be avoided (technically subsumed by the parameters,
   but lighter so we factor them in too) --
   see the Section A.1 in appendix.pdf *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT set&quot;</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Constructor-like operator on the model: *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CCTOR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::var_TT, &#39;a, &#39;a TT &#215; (&#39;a P &#8658; &#39;a C), &#39;a TT &#215; (&#39;a P &#8658; &#39;a C)) F &#8658; &#39;a P &#8658; &#39;a C&quot;</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Map- and freshness- like operators on the model: *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mmapC</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::var_TT &#8658; &#39;a) &#8658; &#39;a TT &#8658; &#39;a C &#8658; &#39;a C&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>FFVarsC</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT TT &#8658; &#39;a C &#8658; &#39;a set&quot;</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Map- and freshness- like operators for the parameters: *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mapP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::var_TT &#8658; &#39;a) &#8658; &#39;a P &#8658; &#39;a P&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>FVarsP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT P &#8658; &#39;a set&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The model axiomatization: *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>  </span><span>small_A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|A| &lt;o bound (any::&#39;a :: var_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The smallness condition that turns a term-like structure into a parameter structure    *)</span></span></span></span></span><span>
</span><span>  </span><span>small_FVarsP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; p :: &#39;a P. |FVarsP p| &lt;o bound (any::&#39;a :: var_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Parameters form a term-like structure: *)</span></span></span></span></span><span>
</span><span>  </span><span>termLikeStr_mapP_FVarsP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;termLikeStr mapP FVarsP&quot;</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Next are the two model clauses from the paper, more precisely from the Section A.2 (from appendix.pdf) which
     deals with full-fledged corecursion). *)</span></span></span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Condition (VC): *)</span></span></span></span></span><span>
</span><span>  </span><span>FFVarsC_CCTOR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; X p.
  (&#8704; t pd p. (t,pd) &#8712; set3_F X &#8746; set4_F X &#10230; FFVarsC t (pd p) &#8838; FFVars t &#8746; FVarsP p &#8746; A)
  &#10233; &#8213;&#8249; L&#39;s twist: &#8250; set2_F X &#8745; (FVarsP p &#8746; A) = {}
  &#10233; FFVarsC (cctor (map_F id id fst fst X)) (CCTOR X p) &#8838;
      FFVars (cctor (map_F id id fst fst X)) &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Condition (MC): *)</span></span></span></span></span><span>
</span><span>  </span><span>mmapC_CCTOR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; u X (p :: &#39;a P).
  bij u &#10233; |supp u| &lt;o bound(any::&#39;a :: var_TT) &#10233;
  imsupp u &#8745; A = {} &#10233;
  mmapC u (cctor (map_F id id fst fst X)) (CCTOR X p) =
  CCTOR (map_F u u (&#955; (t,pd). (map_TT u t, mmapfn mapP mmapC u t pd))
                   (&#955; (t,pd). (map_TT u t, mmapfn mapP mmapC u t pd)) X)
        (mapP u p)&quot;</span></span></span><span>
</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Models form a term-like structure: *)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>termLikeStr_mmapC_FFVarsC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;termLikeStrC mmapC FFVarsC&quot;</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Defined analogously to the FVarsB: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FFVarsBC X p &#8801; &#8899; (t,pd) &#8712; set4_F X. (FFVars t &#8746; FFVarsC t (pd p)) - set2_F X&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapPC &#8801; mmapfn mapP mmapC&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapP_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapP id = id&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>termLikeStr_mapP_FVarsP</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>termLikeStr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapP_o</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233; bij v &#10233; |supp v| &lt;o bound (any::&#39;a) &#10233;
  mapP (u o v) = mapP u o mapP v&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>termLikeStr_mapP_FVarsP</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>termLikeStr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapP_cong_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233;
 (&#8896; a. a &#8712; FVarsP p &#10233; u a = a) &#10233; mapP u p = p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>termLikeStr_mapP_FVarsP</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>termLikeStr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_FVarsP_mapP</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233;
 u a &#8712; FVarsP (mapP u p) &#10231; a &#8712; FVarsP p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>termLikeStr_mapP_FVarsP</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>termLikeStr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapP_id2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapP id p = p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapP_id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapP_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233; bij v &#10233; |supp v| &lt;o bound (any::&#39;a) &#10233;
 mapP (u o v) t = mapP u (mapP v t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>termLikeStr_mapP_FVarsP</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>termLikeStr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapP_bij_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound (any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (mapP u) &#8743; inv (mapP u) = mapP (inv u)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapP u o mapP (inv u) = id&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>mapP_o</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapP (inv u) o mapP u = id&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>mapP_o</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_iff</span><span> </span><span>inv_unique_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mapP_bij</span><span> </span><span class="delimiter">=</span><span> </span><span>mapP_bij_inv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mapP_inv</span><span> </span><span class="delimiter">=</span><span> </span><span>mapP_bij_inv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapP_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound (any::&#39;a::var_TT)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound (any::&#39;a)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; a. a &#8712; FVarsP p &#10233; u a = v a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapP u p = mapP v p&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapP (inv v o u) p = p&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>mapP_cong_id</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_inv_bound</span><span> </span><span>supp_comp_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>mapP_comp</span><span> </span><span>mapP_inv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span> </span><span>supp_comp_bound</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>inv_simp2</span><span> </span><span>mapP_bij_inv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_FVarsP_mapP_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233; a &#8712; FVarsP (mapP u p) &#10231; inv u a &#8712; FVarsP p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_FVarsP_mapP</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv u a&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FVarsP_mapP</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound (any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsP (mapP u p) = {u a | a.  a &#8712; FVarsP p}&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?L = ?R&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv u a&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_FVarsP_mapP_inv</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapP_inj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233; mapP u p = mapP u p&#39; &#10231; p = p&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mapP_bij_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Version of mmapC_CCTOR that assumes freshness for the parameter as well:   *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapC_CCTOR2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u &#8745; (FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;mmapC u (cctor (map_F id id fst fst X)) (CCTOR X p) =
  CCTOR (map_F u u (&#955; (t,pd). (map_TT u t,mmapfn mapP mmapC u t pd))
                   (&#955; (t,pd). (map_TT u t,mmapfn mapP mmapC u t pd)) X)
        p&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u &#8745; FVarsP p = {}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u &#8745; A = {}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapP u p = p&quot;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>mapP_cong_id</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span>i1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mmapC_CCTOR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span> </span><span>i2</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The raw-term-based model infrastructure *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>CTOR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::var_TT, &#39;a, &#39;a T &#215; (&#39;a P &#8658; &#39;a C), &#39;a T &#215; (&#39;a P &#8658; &#39;a C)) F &#8658; &#39;a P &#8658; &#39;a C&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;CTOR X &#8801; CCTOR (map_F id id (map_prod abs_TT id) (map_prod abs_TT id) X)&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Compatibility of the preterm constructor with alpha: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CTOR_alpha</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F id id (rel_prod alpha (=)) (rel_prod alpha (=)) X Y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CTOR X = CTOR Y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CTOR_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>CCTOR</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>F.rel_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span>F_rel_map_right_bij</span><span class="delimiter">[</span><span>OF</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span class="delimiter">]</span><span>
</span><span>    </span><span>id_o</span><span> </span><span>inv_id</span><span> </span><span>eq_OO</span><span>
</span><span>    </span><span>F_rel_map_left</span><span class="delimiter">[</span><span>OF</span><span> </span><span>supp_id_bound</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F.rel_mono_strong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>OO_def</span><span> </span><span>Grp_def</span><span> </span><span>TT.abs_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapC_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapC id t = id&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>termLikeStr_mmapC_FFVarsC</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>termLikeStrC_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapC_o</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233; bij v &#10233; |supp v| &lt;o bound (any::&#39;a) &#10233;
 mmapC (u o v) t = mmapC u t o mmapC v t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>termLikeStr_mmapC_FFVarsC</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>termLikeStrC_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapC_cong_id</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233;
 (&#8896; a. a &#8712; FFVarsC t d &#10233; u a = a) &#10233; mmapC u t d = d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>termLikeStr_mmapC_FFVarsC</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>termLikeStrC_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_FFVarsC_mmapC</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233;
 u a &#8712; FFVarsC (map_TT u t) (mmapC u t d) &#10231; a &#8712; FFVarsC t d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>termLikeStr_mmapC_FFVarsC</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>termLikeStrC_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapC_id2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapC id t d = d&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mmapC_id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapC_comp</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233; bij v &#10233; |supp v| &lt;o bound (any::&#39;a) &#10233;
 mmapC (u o v) t d = mmapC u t (mmapC v t d)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>termLikeStr_mmapC_FFVarsC</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>termLikeStrC_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapC_bij_inv</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound (any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (mmapC u t) &#8743; inv (mmapC u t) = mmapC (inv u) t&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapC u t o mmapC (inv u) t = id&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>mmapC_o</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapC (inv u) t o mmapC u t = id&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>mmapC_o</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_iff</span><span> </span><span>inv_unique_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mmapC_bij</span><span> </span><span class="delimiter">=</span><span> </span><span>mmapC_bij_inv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mmapC_inv</span><span> </span><span class="delimiter">=</span><span> </span><span>mmapC_bij_inv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapC_cong</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound (any::&#39;a::var_TT)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound (any::&#39;a)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; a. a &#8712; FFVarsC t d &#10233; u a = v a&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapC u t d = mmapC v t d&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapC (inv v o u) t d = d&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>mmapC_cong_id</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_inv_bound</span><span> </span><span>supp_comp_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>mmapC_comp</span><span> </span><span>mmapC_inv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span> </span><span>supp_comp_bound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>inv_simp2</span><span> </span><span>mmapC_bij_inv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_FFVarsC_mmapC_inv</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233;
 a &#8712; FFVarsC (map_TT u t) (mmapC u t d) &#10231; inv u a &#8712; FFVarsC t d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_FFVarsC_mmapC</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv u a&quot;</span></span></span><span> </span><span>t</span><span> </span><span>d</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FFVarsC_mmapC</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound (any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FFVarsC (map_TT u t) (mmapC u t d) = {u a | a.  a &#8712; FFVarsC t d}&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?L = ?R&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv u a&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_FFVarsC_mmapC_inv</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapC_inj</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233;
 mmapC u t d = mmapC u t d&#39; &#10231; d = d&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mmapC_bij_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapPC_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapPC id t = id&quot;</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mmapfn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapPC_o</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233; bij v &#10233; |supp v| &lt;o bound (any::&#39;a) &#10233;
 mmapPC (u o v) t = mmapPC u t o mmapPC v t&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mmapfn_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>mapP_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>mapP_inv</span><span> </span><span>mmapC_comp</span><span>
</span><span>    </span><span>supp_inv_bound</span><span> </span><span>supp_comp_bound</span><span> </span><span>o_inv_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapPC_id2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapPC id t d = d&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mmapPC_id</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapPC_comp</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233; bij v &#10233; |supp v| &lt;o bound (any::&#39;a) &#10233;
 mmapPC (u o v) t d = mmapPC u t (mmapPC v t d)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mmapfn_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>mapP_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>mapP_inv</span><span> </span><span>mmapC_comp</span><span>
</span><span>    </span><span>supp_inv_bound</span><span> </span><span>supp_comp_bound</span><span> </span><span>o_inv_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapPC_bij_inv</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound (any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (mmapPC u t) &#8743; inv (mmapPC u t) = mmapPC (inv u) t&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapPC u t o mmapPC (inv u) t = id&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>mmapPC_o</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapPC (inv u) t o mmapPC u t = id&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>mmapPC_o</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_iff</span><span> </span><span>inv_unique_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mmapPC_bij</span><span> </span><span class="delimiter">=</span><span> </span><span>mmapPC_bij_inv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mmapPC_inv</span><span> </span><span class="delimiter">=</span><span> </span><span>mmapPC_bij_inv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapPC_inj</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a &#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::var_TT) &#10233;
 mmapPC u t d = mmapPC u t d&#39; &#10231; d = d&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mmapPC_bij_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*******)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Any extended model is an &quot;renaming&quot; model: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CCTOR_rename</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::var_TT, &#39;a, &#39;a TT &#215; (&#39;a P &#8658; &#39;a C),&#39;a TT &#215; (&#39;a P &#8658; &#39;a C)) F&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span> </span><span>u</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8801; map_F id id fst fst X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X&#39; &#8801; map_F u u (&#955;(t, pd). (map_TT u t, mmapPC u t pd))
                       (&#955;(t, pd). (map_TT u t, mmapPC u t pd)) X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; &#8801; map_F id id fst fst X&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704; t pd p. (t,pd) &#8712; set3_F X &#8746; set4_F X &#10230; FFVarsC t (pd p) &#8838; FFVars t &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u_imsupp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u &#8745; (FFVars (cctor x) &#8746; FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* This one does not have to assumed for this proof to go through,
   meaning the model conditions actually imply a stronger
   version of CCTOR_rename: *)</span></span></span></span></span><span> </span><span>us</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` set2_F X &#8745; set2_F X = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CCTOR X p = CCTOR X&#39; p&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>us</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F X &#8838; imsupp u&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FFVars (cctor x) &#8745; imsupp u = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u_imsupp&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u &#8745; (FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_imsupp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>iu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (inv u)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp (inv u)| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Xu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FFVarsC (cctor x) (CCTOR X p) &#8745; imsupp u = {}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FFVarsC_CCTOR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>S</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span>u_imsupp</span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set1_F X = set1_F x&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F X = set2_F x&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; t pa. (t, pa) &#8712; set3_F X &#10233; t &#8712; set3_F x&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; t pa. (t, pa) &#8712; set4_F X &#10233; t &#8712; set4_F x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>x_def</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cctor x&#39; = cctor x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x&#39;_def</span><span> </span><span>x_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>supp_id_bound</span><span> </span><span>u</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span> </span><span>u</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x_def</span><span> </span><span>x&#39;_def</span><span> </span><span>X&#39;_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>cctor_eq_intro_map_TT</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>F_set_map</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>id_on_def</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>t</span><span> </span><span>pa</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>x_X</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>x_X</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xu</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>x_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FFVars_simps</span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F_map_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span>supp_id_bound</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xu</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>x_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>FFVars_simps</span><span> </span><span>x_X</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span> </span><span>pd</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>map_TT_cong_id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xu</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>x_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>FFVars_simps</span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>x_X</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>22</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CCTOR X&#39; p = mmapC u (cctor x) (CCTOR X p)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mmapC_CCTOR2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span> </span><span>u_imsupp&#39;</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>X</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>x_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>CCTOR</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapC (inv u) (cctor x) (CCTOR X p) = CCTOR X p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>mmapC_cong_id</span><span class="delimiter">[</span><span>OF</span><span> </span><span>iu</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Xu</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>x_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = mmapC (inv u) (cctor x&#39;) (CCTOR X&#39; p)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>22</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span>OF</span><span> </span><span>supp_id_bound</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span> </span><span>u</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mmapC_comp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>iu</span><span> </span><span>u</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapC (inv u) (cctor x) (CCTOR X p) = mmapC (inv u) (cctor x&#39;) (CCTOR X&#39; p)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>2</span><span> </span><span>x_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mmapC_inj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>iu</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Any &quot;renaming&quot; model is a &quot;congruence&quot; model.  *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CCTOR_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>X</span><span> </span><span>X&#39;</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::var_TT,&#39;a,&#39;a TT &#215; (&#39;a P &#8658; &#39;a C), &#39;a TT &#215; (&#39;a P &#8658; &#39;a C)) F&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span> </span><span>u&#39;</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a&#8658;&#39;a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8801; map_F id id fst fst X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; &#8801; map_F id id fst fst X&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o |UNIV::&#39;a set|&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u&#39;| &lt;o |UNIV::&#39;a set|&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;t pd p. (t, pd) &#8712; set3_F X &#8746; set4_F X &#10230; FFVarsC t (pd p) &#8838; FFVars t &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;t pd p. (t, pd) &#8712; set3_F X&#39; &#8746; set4_F X&#39; &#10230; FFVarsC t (pd p) &#8838; FFVars t &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>imsupp_u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u &#8745; (FFVars (cctor x) &#8746; FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>us</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` set2_F X &#8745; set2_F X = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>imsupp_u&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u&#39; &#8745; (FFVars (cctor x&#39;) &#8746; FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>us&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u&#39; ` set2_F X&#39; &#8745; set2_F X&#39; = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F (inv u&#39; o u) (inv u&#39; o u)
        (&#955;(t, pd) (t&#39;, pd&#39;). map_TT u t = map_TT u&#39; t&#39; &#8743; mmapPC u t pd = mmapPC u&#39; t&#39; pd&#39;)
        (&#955;(t, pd) (t&#39;, pd&#39;). map_TT u t = map_TT u&#39; t&#39; &#8743; mmapPC u t pd = mmapPC u&#39; t&#39; pd&#39;) X X&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CCTOR X p = CCTOR X&#39; p&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>iu&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (inv u&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp (inv u&#39;)| &lt;o |UNIV::&#39;a set|&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CCTOR X p = CCTOR (map_F u u (&#955; (t,pd). (map_TT u t,mmapPC u t pd))
                            (&#955; (t,pd). (map_TT u t,mmapPC u t pd)) X) p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CCTOR_rename</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span> </span><span>S</span><span> </span><span>imsupp_u</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>x_def</span><span class="delimiter">]</span><span> </span><span>us</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = CCTOR (map_F u&#39; u&#39; (&#955; (t,pd). (map_TT u&#39; t,mmapPC u&#39; t pd))
                        (&#955; (t,pd). (map_TT u&#39; t,mmapPC u&#39; t pd)) X&#39;) p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>CCTOR</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>F.rel_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span>F_rel_map_right_bij</span><span class="delimiter">[</span><span>OF</span><span> </span><span>supp_id_bound</span><span> </span><span>u&#39;</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span> </span><span>u&#39;</span><span class="delimiter">]</span><span>
</span><span>    </span><span>o_id</span><span> </span><span>inv_id</span><span> </span><span>eq_OO</span><span>
</span><span>    </span><span>F_rel_map_left</span><span class="delimiter">[</span><span>OF</span><span> </span><span>supp_inv_bound</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u&#39;</span><span class="delimiter">]</span><span> </span><span>u</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bij_imp_bij_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u&#39;</span><span class="delimiter">]</span><span> </span><span>u</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F_rel_mono_strong1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>r</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>iu&#39;</span><span> </span><span>supp_comp_bound</span><span> </span><span>OO_def</span><span> </span><span>Grp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = CCTOR X&#39; p&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>CCTOR_rename</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u&#39;</span><span> </span><span>S&#39;</span><span> </span><span>imsupp_u&#39;</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>x&#39;_def</span><span class="delimiter">]</span><span> </span><span>us&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The recursor is developed for these models. *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mapC</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::var_TT &#8658; &#39;a) &#8658; &#39;a T &#8658; &#39;a C &#8658; &#39;a C&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mapC u t d &#8801; mmapC u (abs_TT t) d&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FVarsC</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT T &#8658; &#39;a C &#8658; &#39;a set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsC t d &#8801; FFVarsC (abs_TT t) d&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Swapping for functions involving (quotiented) terms -- just a useful notation *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mapfn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;a::var_TT &#8658; &#39;a) &#8658; &#39;c &#8658; &#39;c) &#8658; ((&#39;a &#8658; &#39;a) &#8658; &#39;a T &#8658; &#39;d &#8658; &#39;d) &#8658;
 (&#39;a &#8658; &#39;a) &#8658; &#39;a T &#8658; (&#39;c &#8658; &#39;d) &#8658; (&#39;c &#8658; &#39;d)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mapfn swp1 swp2 &#8801; &#955; u t cd c. swp2 u t (cd (swp1 (inv u) c))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapPC &#8801; mapfn mapP mapC&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapPC_abs_TT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapPC u (abs_TT t) pd = mapPC u t pd&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fun_eq_iff</span><span> </span><span>mapfn_def</span><span> </span><span>mmapfn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mapC_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FVarsC_alpha</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha t t&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsC t&#39; d = FVarsC t d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVarsC_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TT.abs_eq_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>FVars_def2</span><span> </span><span class="delimiter">=</span><span> </span><span>FFVars.abs_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapC_alpha</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha t t&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapC u t = mapC u t&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mapC_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TT.abs_eq_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapPC_alpha</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha t t&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapPC u t = mapPC u t&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fun_eq_iff</span><span> </span><span>mapfn_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapC_alpha</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The variant of the congruence rule for unquotiented terms: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CTOR_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u&#39;| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704; t pd p. (t,pd) &#8712; set3_F X &#8746; set4_F X &#10230; FVarsC t (pd p) &#8838; FVars t &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704; t pd p. (t,pd) &#8712; set3_F X&#39; &#8746; set4_F X&#39; &#10230; FVarsC t (pd p) &#8838; FVars t &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u &#8745; (FVars (ctor (map_F id id fst fst X)) &#8746; FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;u ` set2_F X &#8745; set2_F X = {}&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u&#39; &#8745; (FVars (ctor (map_F id id fst fst X&#39;)) &#8746; FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;u&#39; ` set2_F X&#39; &#8745; set2_F X&#39; = {}&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F (inv u&#39; o u) (inv u&#39; o u)
     (&#955;(t,pd) (t&#39;,pd&#39;). alpha (map_T u t) (map_T u&#39; t&#39;) &#8743; mapPC u t pd = mapPC u&#39; t&#39; pd&#39;)
     (&#955;(t,pd) (t&#39;,pd&#39;). alpha (map_T u t) (map_T u&#39; t&#39;) &#8743; mapPC u t pd = mapPC u&#39; t&#39; pd&#39;)
     X X&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CTOR X p = CTOR X&#39; p&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>iu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (inv u&#39; &#8728; u)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp (inv u&#39; &#8728; u)| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_inv_bound</span><span> </span><span>supp_comp_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;asSS (asBij u) = u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;asSS (asBij u&#39;) = u&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>asSS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CTOR_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CCTOR_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVarsC_def</span><span> </span><span>FVars_def2</span><span> </span><span>F_set_map_id</span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVarsC_def</span><span> </span><span>FVars_def2</span><span> </span><span>F_set_map_id</span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVarsC_def</span><span> </span><span>FVars_def2</span><span> </span><span>F_set_map_id</span><span> </span><span>image_def</span><span> </span><span>F.map_comp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F.map_comp</span><span> </span><span>abs_TT_ctor</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVarsC_def</span><span> </span><span>FVars_def2</span><span> </span><span>F_set_map_id</span><span> </span><span>image_def</span><span> </span><span>F.map_comp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F.map_comp</span><span> </span><span>abs_TT_ctor</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVarsC_def</span><span> </span><span>FVars_def2</span><span> </span><span>F_set_map_id</span><span> </span><span>image_def</span><span> </span><span>F.map_comp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F.map_comp</span><span> </span><span>abs_TT_ctor</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVarsC_def</span><span> </span><span>FVars_def2</span><span> </span><span>F_set_map_id</span><span> </span><span>image_def</span><span> </span><span>F.map_comp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F.map_comp</span><span> </span><span>abs_TT_ctor</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>F_rel_map_left</span><span class="delimiter">[</span><span>OF</span><span> </span><span>iu</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>supp_id_bound</span><span> </span><span>iu</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>F_rel_map_right_bij</span><span class="delimiter">[</span><span>OF</span><span> </span><span>iu</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span> </span><span>iu</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F_rel_mono_strong1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>2</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>iu</span><span> </span><span>Grp_def</span><span> </span><span>OO_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>map_TT.abs_eq</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>TT.abs_eq_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mmapfn_def</span><span> </span><span>mapfn_def</span><span> </span><span>fun_eq_iff</span><span> </span><span>mapC_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Raw-term-based version of the assumptions: *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* For the first block: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FVarsC_CTOR</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704; t pd p. (t,pd) &#8712; set3_F X &#8746; set4_F X &#10230; FVarsC t (pd p) &#8838; FVars t &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F X &#8745; (FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsC (ctor (map_F id id fst fst X)) (CTOR X p) &#8838;
       FVars (ctor (map_F id id fst fst X)) &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?X</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F id id (map_prod abs_TT id) (map_prod abs_TT id) X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F id id (abs_TT &#8728; fst) (abs_TT &#8728; fst) X = map_F id id fst fst ?X&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>F.map_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CTOR_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVarsC_def</span><span> </span><span>FVars_def2</span><span> </span><span>F_set_map_id</span><span> </span><span>image_def</span><span> </span><span>abs_TT_ctor</span><span> </span><span>F.map_comp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>FFVarsC_CCTOR</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_set_map_id</span><span> </span><span>FVarsC_def</span><span> </span><span>FVars_def2</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* For the third block: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapC_CTOR</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u &#8745; A = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapC u (ctor (map_F id id fst fst X)) (CTOR X p) =
  CTOR (map_F u u (&#955; (t,pd). (map_T u t, mapfn mapP mapC u t pd))
                  (&#955; (t,pd). (map_T u t, mapfn mapP mapC u t pd)) X)
       (mapP u p)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?X</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F id id (map_prod abs_TT id) (map_prod abs_TT id) X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F id id (abs_TT &#8728; fst) (abs_TT &#8728; fst) X = map_F id id fst fst ?X&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>F.map_comp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;asSS (asBij u) = u&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>asSS_def</span><span> </span><span>asBij_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CTOR_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mapC_def</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>supp_id_bound</span><span> </span><span>u</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>abs_TT_ctor</span><span> </span><span>F.map_comp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mmapC_CCTOR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>CCTOR</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>supp_id_bound</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F_map_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>u</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_TT.abs_eq</span><span> </span><span>mapfn_def</span><span> </span><span>mmapfn_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapPC_CTOR</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u &#8745; A = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;mapPC u (ctor (map_F id id fst fst X)) (CTOR X) =
 CTOR (map_F u u (&#955; (t,pd). (map_T u t, mapfn mapP mapC u t pd))
                 (&#955; (t,pd). (map_T u t, mapfn mapP mapC u t pd)) X)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>iu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (inv u)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp (inv u)| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>mapfn_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fun_eq_iff</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mapC_CTOR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>mapP_comp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>iu</span><span class="delimiter">,</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*    *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>suitable</span><span> </span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;a::var_TT,&#39;a,&#39;a T,&#39;a T)F &#8658; &#39;a P &#8658; (&#39;a &#8658; &#39;a)) &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick &#8801;
 &#8704; x p. bij (pick x p) &#8743; |supp (pick x p)| &lt;o bound(any::&#39;a) &#8743;
        imsupp (pick x p) &#8745; (FVars (ctor x) &#8746; FVarsP p &#8746; A - set2_F x) = {} &#8743;
        pick x p ` (set2_F x) &#8745; (FVars (ctor x) &#8746; FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suitable_FVarsB</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp (pick x p) &#8745; FVarsB x = {}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsB x &#8838; FVars (ctor x) &#8746; FVarsP p &#8746; A - set2_F x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>  </span><span>FVars_intros</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;a::var_TT,&#39;a,&#39;a T,&#39;a T)F &#8658; &#39;a P &#8658; (&#39;a &#8658; &#39;a)) &#8658; &#39;a T &#8658; &#39;a P &#8658; &#39;a C&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;f pick (ctor x) p =
 (if suitable pick
 then let x&#39; = map_F id (pick x p) id (map_T (pick x p)) x in
      CTOR (map_F id id (&#955; t. (t, f pick t)) (&#955; t. (t, f pick t)) x&#39;) p
 else undefined)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_image {(s,t). subshape s t} (fst o snd)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_subshape</span><span> </span><span>suitable_def</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>set3_F_subshape</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>pick</span><span> </span><span>x</span><span> </span><span>p</span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subshape.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv (pick x p)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>suitable_def</span><span> </span><span>supp_inv_bound</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>T_map_id</span><span> </span><span>alpha_refl</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>f.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f pick (ctor x) p =
 CTOR (map_F id (pick x p)
         (&#955; t. (t, f pick t))
         (&#955; t. (map_T (pick x p) t, f pick (map_T (pick x p) t)))
         x) p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>f.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>suitable_def</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>CTOR</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F_map_cong</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_FVars</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsC t (f pick t p) &#8838; FVars t &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>p</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>subshape_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>subsh</span><span> </span><span>t</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = ctor x&quot;</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* and &quot;set2_F x &#8745; (FVarsP p &#8746; A) = {}&quot;
   find_theorems name: avoid *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>pick</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (pick x p)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp (pick x p)| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ipick</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp (pick x p) &#8745; FVarsB x = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick x p ` set2_F x &#8745; (FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_FVarsB</span><span class="delimiter">[</span><span>OF</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>invpick</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (inv (pick x p))&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp (inv (pick x p))| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pick</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?X</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(map_F id (pick x p)
                (&#955;t. (t, f pick t))
                (&#955;t. (map_T (pick x p) t, f pick (map_T (pick x p) t))) x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8801; ?X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>al</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (ctor (map_F id id fst fst X)) (ctor x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pick</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>suitable_def</span><span> </span><span>supp_id_bound</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>alpha_sym</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>alpha.intros</span><span class="delimiter">[</span><span>OF</span><span> </span><span>pick</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ipick</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>id_on_def</span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span>FVars_ctor</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_rel_map</span><span> </span><span>supp_id_bound</span><span> </span><span>pick</span><span> </span><span>Grp_def</span><span> </span><span>OO_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F.rel_refl_strong</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>alpha_refl</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsC (ctor (map_F id id fst fst X)) (CTOR X p) &#8838;
        FVars (ctor (map_F id id fst fst X)) &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>FVarsC_CTOR</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>tt</span><span> </span><span>pd</span><span> </span><span>pp</span><span> </span><span>xx</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pick</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span> </span><span>X_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subsh</span><span class="delimiter">[</span><span>of</span><span> </span><span>tt</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>set3_F_subshape</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>tt</span><span> </span><span>pd</span><span> </span><span>pp</span><span> </span><span>xx</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pick</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span> </span><span>X_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subsh</span><span class="delimiter">[</span><span>of</span><span> </span><span>tt</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>subshape.intros</span><span class="delimiter">[</span><span>OF</span><span> </span><span>invpick</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pick</span><span> </span><span>invpick</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>T_map_id</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>alpha_refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ipick</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span> </span><span>pick</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = FVars (ctor x) &#8746; FVarsP p &#8746; A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_FVars</span><span class="delimiter">[</span><span>OF</span><span> </span><span>al</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsC (ctor (map_F id id fst fst X)) (CTOR X p) &#8838; FVars (ctor x) &#8746; FVarsP p &#8746; A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>FVarsC_alpha</span><span class="delimiter">[</span><span>OF</span><span> </span><span>al</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The &quot;monster lemma&quot;: termLikeStr and alpha must be treated in one shot
(and we also do &quot;pick&quot;-irrelevance at the same time).
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_swap_alpha</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u &#8745; A = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha t t&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f pick (map_T u t) = mapPC u t (f pick t) &#8743;
       f pick t = f pick&#39; t&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>pick</span><span> </span><span>pick&#39;</span><span> </span><span>u</span><span> </span><span>t&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>subshape_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>subsh</span><span> </span><span>t</span><span> </span><span>pick</span><span> </span><span>pick&#39;</span><span> </span><span>u</span><span> </span><span>t&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IHsw</span><span> </span><span class="delimiter">=</span><span> </span><span>subsh</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`suitable pick&#39;`</span></span></span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>alpha_refl</span><span class="delimiter">,</span><span>
</span><span>      </span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>u</span><span> </span><span class="delimiter">=</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`bij u`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`|supp u| &lt;o bound(any::&#39;a)`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`imsupp u &#8745; A = {}`</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>p</span><span> </span><span class="delimiter">=</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`suitable pick`</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ASsw</span><span> </span><span class="delimiter">=</span><span> </span><span>p</span><span> </span><span>u</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IHal</span><span> </span><span class="delimiter">=</span><span> </span><span>subsh</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`suitable pick`</span></span></span><span> </span><span>_</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`bij u`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`|supp u| &lt;o |UNIV|`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`imsupp u &#8745; A = {}`</span></span></span><span class="delimiter">,</span><span>
</span><span>      </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ASal</span><span> </span><span class="delimiter">=</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`suitable pick`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`suitable pick&#39;`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`alpha t t&#39;`</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = ctor x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>xx</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xx = map_F u u (map_T u) (map_T u) x&quot;</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*   *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>iu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (inv u)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp (inv u)| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp (inv u) &#8745; A = {}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_inv_bound</span><span> </span><span>imsupp_inv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a. a &#8712; A &#10233; u a = a&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a. u a &#8712; A &#10233; u a = a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>supp_def</span><span> </span><span>imsupp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*   *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>p_iu</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p_iu &#8801; mapP (inv u) p&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>x_u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x_u &#8801; map_F u u (map_T u) (map_T u) x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sw_pp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapP u p_iu = p&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p_iu_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>iu</span><span> </span><span>mapP_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;L &#8801; pick x_u p &#8728; u&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R &#8801; u &#8728; pick x p_iu&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>XXl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;XXl &#8801; map_F u L
              (&#955;t. (map_T u t, f pick (map_T u t)))
              (&#955;t. (map_T L t, f pick (map_T L t))) x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>XXr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;XXr &#8801; map_F u R
              (&#955;t. (map_T u t, mapPC u t (f pick t)))
              (&#955;t. (map_T R t, mapPC u (map_T (pick x p_iu) t)
                                        (f pick (map_T (pick x p_iu) t)))) x&quot;</span></span></span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X = (map_F id (pick x p_iu)
             (&#955;t. (t, f pick t))
             (&#955;t. (map_T (pick x p_iu) t, f pick (map_T (pick x p_iu) t))) x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>XXr_X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;XXr = map_F u u
                         (&#955;(t, pd). (map_T u t, mapPC u t pd))
                         (&#955;(t, pd). (map_T u t, mapPC u t pd)) X&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XXr_def</span><span> </span><span>X_def</span><span> </span><span>R_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>suitable_def</span><span> </span><span>u</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_comp_bound</span><span> </span><span>supp_id_bound</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>00</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; t&#39;. t&#39; &#8712; set3_F x &#10233; f pick (map_T u t&#39;) = mapPC u t&#39; (f pick t&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHsw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>p</span><span> </span><span>u</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>set3_F_subshape</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>11</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; t&#39;. t&#39; &#8712; set4_F x &#10233;
        let tt&#39; = (map_T (pick x p_iu) t&#39;) in
        f pick (map_T u tt&#39;) = mapPC u tt&#39; (f pick tt&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>IHsw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>p</span><span> </span><span>u</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subshape.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv (pick x p_iu)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>suitable_def</span><span> </span><span>supp_inv_bound</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>T_map_id</span><span> </span><span>alpha_refl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*   *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>al</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (ctor x) (ctor (map_F id id fst fst X))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>alpha.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick x p_iu&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp (pick x p_iu)| &lt;o |UNIV::&#39;a set|&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (pick x p_iu)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>suitable_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id_on (FVarsB x) (pick x p_iu)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>id_on_def</span><span> </span><span>suitable_def</span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span>FVars_ctor</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F id (pick x p_iu) alpha (&#955;s. alpha (map_T (pick x p_iu) s)) x (map_F id id fst fst X)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_rel_map</span><span> </span><span>suitable_def</span><span> </span><span>X_def</span><span> </span><span>Grp_def</span><span> </span><span>OO_def</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F.rel_refl_strong</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>alpha_refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; set2_F x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u a &#8712; set2_F x_u&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x_u_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>F_set_map</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;L a &#8713; FVars (ctor x_u) &#8746; FVarsP p &#8746; A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_def</span><span> </span><span>o_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;L a &#8713; u ` FVars (ctor x) &#8746; FVarsP p &#8746; A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x_u_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>F_set_map</span><span> </span><span>FVars_ctor</span><span> </span><span>FVars_map_T</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>L1</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars (ctor x) &#8746; inv u ` FVarsP p &#8746; A - set2_F x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u a &#8712; FVars (ctor x_u) &#8746; FVarsP p &#8746; A - set2_F x_u&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x_u_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>F_set_map</span><span> </span><span>FVars_ctor</span><span> </span><span>FVars_map_T</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>uA</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;L a = u a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span>L_def</span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>L2</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; set2_F x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick x p_iu a &#8713; FVars (ctor x) &#8746; FVarsP p_iu &#8746; A&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R a &#8713; u ` FVars (ctor x) &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>R_def</span><span> </span><span>p_iu_def</span><span> </span><span>FVarsP_mapP</span><span class="delimiter">[</span><span>OF</span><span> </span><span>iu</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uA</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>R1</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars (ctor x) &#8746; inv u ` FVarsP p &#8746; A - set2_F x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars (ctor x) &#8746; FVarsP p_iu &#8746; A - set2_F x&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p_iu_def</span><span> </span><span>FVarsP_mapP</span><span class="delimiter">[</span><span>OF</span><span> </span><span>iu</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick x p_iu a = a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R a = u a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>R_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>R2</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij L&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp L| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij R&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp R| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_def</span><span> </span><span>R_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>suitable_def</span><span> </span><span>supp_comp_bound</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>set1_F_XXl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set1_F XXl = u ` set1_F x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XXl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>L</span><span> </span><span>u</span><span> </span><span>F_set_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>set2_F_XXl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F XXl = L ` set2_F x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XXl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>L</span><span> </span><span>u</span><span> </span><span>F_set_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;x&#8712;set4_F x. L ` FVars x) - L ` set2_F x = u ` FVarsB x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>FVars_ctor</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>image_iff</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>FVars_XXl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVars (ctor (map_F id id fst fst XXl)) = u ` FVars (ctor x)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XXl_def</span><span> </span><span>FVars_ctor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>L</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>F_set_map</span><span> </span><span>FVars_map_T</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>set2_F_XXl_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F XXl &#8745; (FVars (ctor (map_F id id fst fst XXl)) &#8746; FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L1</span><span> </span><span>set2_F_XXl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_XXl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>set1_F_XXr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set1_F XXr = u ` set1_F x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XXr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>R</span><span> </span><span>u</span><span> </span><span>F_set_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>set2_F_XXr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F XXr = R ` set2_F x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XXr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>R</span><span> </span><span>u</span><span> </span><span>F_set_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;x&#8712;set4_F x. R ` FVars x) - R ` set2_F x = u ` FVarsB x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>FVars_ctor</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>image_iff</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>FVars_XXr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVars (ctor (map_F id id fst fst XXr)) = u ` FVars (ctor x)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XXr_def</span><span> </span><span>FVars_ctor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>R</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>F_set_map</span><span> </span><span>FVars_map_T</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>set2_F_XXr_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F XXr &#8745; (FVars (ctor (map_F id id fst fst XXr)) &#8746; FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R1</span><span> </span><span>set2_F_XXr</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_XXr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*   *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|set2_F XXl| =o |set2_F x|&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|set2_F XXr| =o |set2_F x|&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set2_F_XXl</span><span> </span><span>set2_F_XXr</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_card_of_ordIso</span><span> </span><span>L</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>R</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>card_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|set2_F XXl| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|set2_F XXr| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set2_F_bound</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*   *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Sl</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVars (ctor (map_F id id fst fst XXl)) &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Sr</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVars (ctor (map_F id id fst fst XXr)) &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S &#8801; set2_F XXl &#8746; ?Sl &#8746; set2_F XXr &#8746; ?Sr&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|S| &lt;o bound (any::&#39;a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>regularCard_Un</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bound_Card_order</span><span> </span><span>bound_cinfinite</span><span> </span><span>bound_regularCard</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_bound</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>card_of_FVars_bound</span><span> </span><span>small_FVarsP</span><span> </span><span>small_A</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|- S| =o bound (any::&#39;a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>infinite_UNIV_card_of_minus</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`|S| &lt;o bound (any::&#39;a)`</span></span></span><span> </span><span>Compl_eq_Diff_UNIV</span><span> </span><span>var_TT_infinite</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|set2_F XXl| &lt;o |- S|&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_bound</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ordIso_symmetric</span><span> </span><span>ordLess_ordIso_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ordLess_imp_ordLeq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>KK</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>KKS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;KK &#8838; - S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>KKo</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|set2_F XXl| =o |KK|&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>internalize_card_of_ordLeq2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>interl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F XXl &#8745; KK = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F XXl &#8745; ?Sl = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;KK &#8745; ?Sl = {}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>KKS</span><span> </span><span>set2_F_XXl_int</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp v &#8745; ?Sl = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw v (set2_F XXl) KK&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordIso_ex_bij_betw_supp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>var_TT_infinite</span><span> </span><span>set2_F_bound</span><span> </span><span>KKo</span><span> </span><span>interl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*   *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ww</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v o L o (inv R)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ww</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw ?ww (set2_F XXr) KK&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>bij_betw_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F x&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_betw_def</span><span> </span><span>inj_on_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>R</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>set2_F_XXr</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>bijection.intro</span><span> </span><span>bijection.surj_inv</span><span> </span><span>image_f_inv_f</span><span> </span><span>set2_F_XXr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>bij_betw_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F XXl&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_betw_def</span><span> </span><span>inj_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>L</span><span> </span><span>set2_F_XXl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>v</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>interr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F XXr &#8745; KK = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F XXr &#8745; ?Sr = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;KK &#8745; ?Sr = {}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>KKS</span><span> </span><span>set2_F_XXr_int</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>w</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij w&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp w| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp w &#8745; ?Sr = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw w (set2_F XXr) KK&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ew</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eq_on (set2_F XXr) w ?ww&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_bij_betw_supp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>var_TT_infinite</span><span> </span><span>set2_F_bound</span><span> </span><span>ww</span><span> </span><span>interr</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>evw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eq_on (set2_F x) (v o L) (w o R)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ew</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq_on_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span>set2_F_XXr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars (ctor x)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u a &#8712; FVars (ctor (map_F id id fst fst XXl))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FVars_XXl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>vua</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v (u a) = u a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>FVars_vu</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars (ctor x)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u a &#8712; FVars (ctor (map_F id id fst fst XXr))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FVars_XXr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>vua</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w (u a) = u a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>FVars_wu</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>vu</span><span> </span><span class="delimiter">=</span><span>  </span><span>bij_comp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>v</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>supp_comp_bound</span><span class="delimiter">[</span><span>OF</span><span> </span><span>v</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>u</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ivu</span><span> </span><span class="delimiter">=</span><span> </span><span>bij_imp_bij_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vu</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vu</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>imv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp v &#8745; A = {}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>imw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp w &#8745; A = {}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CTOR XXl p = CTOR XXr p&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CTOR_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>v</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>w</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;t pd p. (t, pd) &#8712; set3_F XXl &#8746; set4_F XXl &#10230;
                     FVarsC t (pd p) &#8838; FVars t &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XXl_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>suitable_def</span><span> </span><span>u</span><span> </span><span>L</span><span> </span><span>supp_id_bound</span><span> </span><span>F_set_map</span><span> </span><span>xx_def</span><span> </span><span>FVars_ctor</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_FVars</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`suitable pick`</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_FVars</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`suitable pick&#39;`</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;t pd p. (t, pd) &#8712; set3_F XXr &#8746; set4_F XXr &#10230;
                     FVarsC t (pd p) &#8838; FVars t &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XXr_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>suitable_def</span><span> </span><span>u</span><span> </span><span>R</span><span> </span><span>supp_id_bound</span><span> </span><span>F_set_map</span><span> </span><span>FVars_ctor</span><span> </span><span>supp_comp_bound</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>t&#39;</span><span> </span><span>a</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_FVars</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`suitable pick`</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_T u t&#39;&quot;</span></span></span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span>00</span><span class="delimiter">[</span><span>of</span><span> </span><span>t&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>t&#39;</span><span> </span><span>a</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_FVars</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`suitable pick`</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_T u (map_T (pick x p_iu) t&#39;)&quot;</span></span></span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span>11</span><span class="delimiter">[</span><span>of</span><span> </span><span>t&#39;</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>Let_def</span><span> </span><span>R_def</span><span> </span><span>T_map_comp</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp v &#8745; ?Sl = {}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp w &#8745; ?Sr = {}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F (inv w &#8728; v) (inv w &#8728; v)
   (&#955;(t, pd) (t&#39;, pd&#39;). alpha (map_T v t) (map_T w t&#39;) &#8743; mapPC v t pd = mapPC w t&#39; pd&#39;)
   (&#955;(t, pd) (t&#39;, pd&#39;). alpha (map_T v t) (map_T w t&#39;) &#8743; mapPC v t pd = mapPC w t&#39; pd&#39;) XXl XXr&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XXl_def</span><span> </span><span>XXr_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span>suitable_def</span><span> </span><span>F_rel_map</span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span>supp_comp_bound</span><span> </span><span>supp_inv_bound</span><span>
</span><span>            </span><span>Grp_def</span><span> </span><span>OO_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F_rel_refl_strong</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span>u</span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span>supp_comp_bound</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span>u</span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span>supp_comp_bound</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span>u</span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span>supp_comp_bound</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; set1_F x&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u a &#8712; set1_F XXl&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>set1_F_XXl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u a &#8712; FVars (ctor (map_F id id fst fst XXl))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_ctor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_set_map_id</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>vua</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v (u a) = u a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u a &#8712; set1_F XXr&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>set1_F_XXr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u a &#8712; FVars (ctor (map_F id id fst fst XXr))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_ctor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_set_map_id</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>wua</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv w (u a) = u a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>w</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(inv u &#8728; (inv w &#8728; v) &#8728; u) a = a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>o_def</span><span> </span><span>vua</span><span> </span><span>wua</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; set2_F x&quot;</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(inv R &#8728; (inv w &#8728; v) &#8728; L) a = a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>evw</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq_on_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span>R</span><span> </span><span>L</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>tt</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tt &#8712; set3_F x&quot;</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T v (map_T u tt)) (map_T w (map_T u tt)) &#8743;
                mapPC v (map_T u tt) (f pick (map_T u tt)) =
                mapPC w (map_T u tt) (mapPC u tt (f pick tt))&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A &#8743; ?B&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="var">?A</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>alpha_bij</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span>FVars_map_T</span><span> </span><span>alpha_refl</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FVars_intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>FVars_vu</span><span> </span><span>FVars_wu</span><span> </span><span>tt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subshape tt t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>set3_F_subshape</span><span> </span><span>tt</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subshape (map_T u tt) t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subshape.intros</span><span class="delimiter">[</span><span>OF</span><span> </span><span>iu</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>alpha_refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>iu</span><span> </span><span>T_map_id</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssvu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subshape (map_T v (map_T u tt)) t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subshape.intros</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ivu</span><span> </span><span>alpha_refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_comp_bound</span><span> </span><span>supp_inv_bound</span><span> </span><span>T_map_id</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?B</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IHsw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssu</span><span> </span><span>p</span><span> </span><span>v</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>imv</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IHsw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ss</span><span> </span><span>p</span><span> </span><span>u</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IHsw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssu</span><span> </span><span>p</span><span> </span><span>w</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>imw</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssvu</span><span> </span><span>p</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>tt</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tt &#8712; set4_F x&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?tt&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_T (pick x p_iu) tt&quot;</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T v (map_T L tt)) (map_T w (map_T R tt)) &#8743;
          mapPC v (map_T L tt) (f pick (map_T L tt)) =
          mapPC w (map_T R tt) (mapPC u ?tt&#39; (f pick ?tt&#39;))&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A &#8743; ?B&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars tt&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v (L a) = w (R a)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; set2_F x&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comp_apply</span><span> </span><span>eq_on_def</span><span> </span><span>evw</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars (ctor x)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tt</span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>FVars_ctor</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FVars_vu</span><span> </span><span>FVars_wu</span><span> </span><span>False</span><span> </span><span>L2</span><span> </span><span>R2</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>vLwR</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="var">?A</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>alpha_bij</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>w</span><span> </span><span>L</span><span> </span><span>R</span><span> </span><span>supp_comp_bound</span><span> </span><span>vLwR</span><span> </span><span>alpha_refl</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subshape tt t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>set4_F_subshape</span><span> </span><span>tt</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subshape (map_T L tt) t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subshape.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv L&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>alpha_refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>L</span><span> </span><span>supp_inv_bound</span><span> </span><span>T_map_id</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ss&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subshape ?tt&#39; t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subshape.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv (pick x p_iu)&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>alpha_refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tt</span><span> </span><span>p</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>suitable_def</span><span> </span><span>supp_inv_bound</span><span> </span><span>T_map_id</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subshape (map_T R tt) t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subshape.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv R&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>alpha_refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tt</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>R</span><span> </span><span>supp_inv_bound</span><span> </span><span>supp_comp_bound</span><span> </span><span>T_map_id</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ssvL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subshape (map_T v (map_T L tt)) t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>L</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subshape.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv (v o L)&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>alpha_refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tt</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>L</span><span> </span><span>supp_inv_bound</span><span> </span><span>supp_comp_bound</span><span> </span><span>T_map_id</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?B</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IHsw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssu</span><span> </span><span>p</span><span> </span><span>v</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>imv</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IHsw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ss&#39;</span><span> </span><span>p</span><span> </span><span>u</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>suitable_def</span><span> </span><span>u</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>R_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IHsw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssR</span><span> </span><span>p</span><span> </span><span>w</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>imw</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ssvL</span><span> </span><span>p</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v ` set2_F XXl &#8745; set2_F XXl = {}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_betw_imp_surj_on</span><span> </span><span>interl</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>v</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w ` set2_F XXr &#8745; set2_F XXr = {}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_betw_imp_surj_on</span><span> </span><span>interr</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>w</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f pick (map_T u t) p = mapPC u t (f pick t) p&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span>mapfn_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mapC_alpha</span><span class="delimiter">[</span><span>OF</span><span> </span><span>al</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_simps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p_iu_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mapC_CTOR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sw_pp</span><span> </span><span>XXr_X</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>map_T_simps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_simps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>p</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* unfolding x_u_def[symmetric] *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>suitable_def</span><span> </span><span>supp_comp_bound</span><span> </span><span>supp_id_bound</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x_u_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>o_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>suitable_def</span><span> </span><span>supp_comp_bound</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>XXl_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(********************* *)</span></span></span></span></span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(********************* *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; = ctor x&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>p&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`suitable pick&#39;`</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f pick t = f pick&#39; t&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*   *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>pk</span><span> </span><span>pk&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pk &#8801; pick x p&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pk&#39; &#8801; pick&#39; x&#39; p&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>pk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij pk&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp pk| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp pk &#8745; (FVars (ctor x) &#8746; FVarsP p &#8746; A - set2_F x) = {}&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;pk ` set2_F x &#8745; ((* set2_F x &#8746;*) FVars (ctor x) &#8746; FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pk&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij pk&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp pk&#39;| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp pk&#39; &#8745; (FVars (ctor x&#39;) &#8746; FVarsP p &#8746; A - set2_F x&#39;) = {}&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;pk&#39; ` set2_F x&#39; &#8745; ((* set2_F x&#39; &#8746;*) FVars (ctor x&#39;) &#8746; FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span>p&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span>pk_def</span><span> </span><span>pk&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?X</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F id pk (&#955;t. (t, f pick t))
                (&#955;t. (map_T pk t, f pick (map_T pk t))) x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?X&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F id pk&#39; (&#955;t. (t, f pick&#39; t))
           (&#955;t. (map_T pk&#39; t, f pick&#39; (map_T pk&#39; t))) x&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>X</span><span> </span><span>X&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8801; ?X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X&#39; &#8801; ?X&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>v</span><span> </span><span>v&#39;</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v &#8801; any 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v&#39; &#8801; any 1&quot;</span></span></span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u &quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id_on (FVarsB x) u&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rxx&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F id u alpha (&#955;s. alpha (map_T u s)) x x&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`alpha t t&#39;`</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span>t&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u_set2_F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` (set2_F x) = set2_F x&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_set2_transfer</span><span class="delimiter">[</span><span>OF</span><span> </span><span>supp_id_bound</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>rel_fun_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>rxx&#39;</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Grp_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>bu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw u (set2_F x) (set2_F x&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bij_imp_bij_betw</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>FVars_x_x&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVars (ctor x) = FVars (ctor x&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`alpha t t&#39;`</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span>t&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha_FVars</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>set1_F_X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set1_F X = set1_F x&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>set2_F_X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F X = pk ` (set2_F x)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pk</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>FVars_ctor</span><span> </span><span>o_def</span><span>
</span><span>            </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>image_def</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bpk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw pk (set2_F x) (set2_F X)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set2_F_X</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_imp_bij_betw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>pk</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsB (map_F id id fst fst X) = FVarsB x&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?L = ?R&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; ?L&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bpk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8713; pk ` set2_F x&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ss &#8712; set4_F x&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; pk ` FVars ss&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pk</span><span> </span><span>F_set_map</span><span> </span><span>FVars_map_T</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars ss&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b = pk a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8713; set2_F x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpk</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ac</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars (ctor x) - set2_F x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_ctor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b = a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pk</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; ?R&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ac</span><span> </span><span>ss</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; ?R&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>tt</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>an</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8713; set2_F x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>at</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars tt&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tt &#8712; set4_F x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ac</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars (ctor x) - set2_F x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_ctor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>pka</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pk a = a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pk</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; ?L&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pk</span><span> </span><span>t</span><span> </span><span>at</span><span> </span><span>pka</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pk</span><span> </span><span>F_set_map</span><span> </span><span>X_def</span><span> </span><span>FVars_map_T</span><span> </span><span>image_def</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>FVars_map_T</span><span> </span><span>image_eqI</span><span> </span><span>pk</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>pk</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>an</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>FVars_X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVars (ctor (map_F id id fst fst X)) = FVars (ctor x)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X_def</span><span> </span><span>FVars_ctor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pk</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>set2_F_X_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F X &#8745; (FVars (ctor (map_F id id fst fst X)) &#8746; FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pk</span><span> </span><span>set2_F_X</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_X</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>set1_F_X&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set1_F X&#39; = set1_F x&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>set2_F_X&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F X&#39; = pk&#39; ` (set2_F x&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pk&#39;</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>FVars_ctor</span><span> </span><span>o_def</span><span>
</span><span>            </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>image_def</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bpk&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw pk&#39; (set2_F x&#39;) (set2_F X&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set2_F_X&#39;</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_imp_bij_betw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>pk&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsB (map_F id id fst fst X&#39;) = FVarsB x&#39;&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?L = ?R&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; ?L&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ss</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bpk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8713; pk&#39; ` set2_F x&#39;&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ss &#8712; set4_F x&#39;&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; pk&#39; ` FVars ss&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pk&#39;</span><span> </span><span>F_set_map</span><span> </span><span>FVars_map_T</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars ss&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b = pk&#39; a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8713; set2_F x&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpk</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ac</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars (ctor x&#39;) - set2_F x&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>ss</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_ctor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b = a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pk&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; ?R&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ac</span><span> </span><span>ss</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; ?R&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>tt</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>an</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8713; set2_F x&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>at</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars tt&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tt &#8712; set4_F x&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ac</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars (ctor x&#39;) - set2_F x&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_ctor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>pka</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pk&#39; a = a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pk&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; ?L&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pk&#39;</span><span> </span><span>t</span><span> </span><span>at</span><span> </span><span>pka</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pk&#39;</span><span> </span><span>F_set_map</span><span> </span><span>X&#39;_def</span><span> </span><span>FVars_map_T</span><span> </span><span>image_def</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>FVars_map_T</span><span> </span><span>image_eqI</span><span> </span><span>pk&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>pk&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>an</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>FVars_X&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVars (ctor (map_F id id fst fst X&#39;)) = FVars (ctor x&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X&#39;_def</span><span> </span><span>FVars_ctor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pk&#39;</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>set2_F_X&#39;_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F X&#39; &#8745; (FVars (ctor (map_F id id fst fst X&#39;)) &#8746; FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pk&#39;</span><span> </span><span>set2_F_X&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_X&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*   *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Ss</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVars (ctor (map_F id id fst fst X)) &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Ss&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVars (ctor (map_F id id fst fst X&#39;)) &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S &#8801; set2_F X &#8746; ?Ss &#8746; set2_F X&#39; &#8746; ?Ss&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|S| &lt;o bound (any::&#39;a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>regularCard_Un</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bound_Card_order</span><span> </span><span>bound_cinfinite</span><span> </span><span>bound_regularCard</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>card_of_FVars_bound</span><span> </span><span>small_FVarsP</span><span> </span><span>small_A</span><span> </span><span>set2_F_bound</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|- S| =o bound (any::&#39;a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>infinite_UNIV_card_of_minus</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`|S| &lt;o bound (any::&#39;a)`</span></span></span><span> </span><span>Compl_eq_Diff_UNIV</span><span> </span><span>var_TT_infinite</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|set2_F X&#39;| &lt;o |- S|&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordIso_symmetric</span><span> </span><span>ordLess_ordIso_trans</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set2_F_bound</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ordLess_imp_ordLeq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>KK</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>KKS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;KK &#8838; - S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>KKo</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|set2_F X&#39;| =o |KK|&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>internalize_card_of_ordLeq2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inter&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F X&#39; &#8745; KK = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F X&#39; &#8745; ?Ss&#39; = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;KK &#8745; ?Ss&#39; = {}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>KKS</span><span> </span><span>set2_F_X&#39;_int</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v&#39;| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp v&#39; &#8745; ?Ss&#39; = {}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pv&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw v&#39; (set2_F X&#39;) KK&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordIso_ex_bij_betw_supp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>var_TT_infinite</span><span> </span><span>set2_F_bound</span><span> </span><span>KKo</span><span> </span><span>inter&#39;</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v&#39;A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp v&#39; &#8745; A = {}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*   *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?vv</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v&#39; o pk&#39; o u o (inv pk)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw ?vv (set2_F X) KK&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>bij_betw_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F x&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_bij_betw_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>pk</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>bpk</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>bij_betw_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F x&#39;&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bu</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>bij_betw_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F X&#39;&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bpk&#39;</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pv&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F X &#8745; KK = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F X &#8745; ?Ss = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;KK &#8745; ?Ss = {}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>KKS</span><span> </span><span>set2_F_X_int</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp v &#8745; ?Ss = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw v (set2_F X) KK&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ew</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eq_on (set2_F X) v ?vv&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_bij_betw_supp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>var_TT_infinite</span><span> </span><span>set2_F_bound</span><span> </span><span>vv</span><span> </span><span>inter</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp v &#8745; A = {}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v ` set2_F X &#8745; set2_F X = {}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_betw_imp_surj_on</span><span> </span><span>inter</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>v</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v&#39;4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v&#39; ` set2_F X&#39; &#8745; set2_F X&#39; = {}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_betw_imp_surj_on</span><span> </span><span>inter&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>pv&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>evw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;eq_on (set2_F x) (v&#39; o pk&#39; o u) (v o pk)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ew</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq_on_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>v&#39;</span><span> </span><span>u</span><span> </span><span>pk</span><span> </span><span>set2_F_X</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CTOR X p = CTOR X&#39; p&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CTOR_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>v</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>v&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>v</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>v4</span><span> </span><span>v&#39;</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>v&#39;4</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;t pd p. (t, pd) &#8712; set3_F X &#8746; set4_F X &#10230;
                  FVarsC t (pd p) &#8838; FVars t &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pk</span><span> </span><span>F_set_map</span><span> </span><span>image_def</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span> </span><span>p</span><span> </span><span>a</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_FVars</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`suitable pick`</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>t</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>pp</span><span> </span><span>a</span><span> </span><span>tt</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_FVars</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`suitable pick`</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_T pk tt&quot;</span></span></span><span> </span><span>pp</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;t pd p. (t, pd) &#8712; set3_F X&#39; &#8746; set4_F X&#39; &#10230;
                  FVarsC t (pd p) &#8838; FVars t &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>X&#39;_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pk&#39;</span><span> </span><span>F_set_map</span><span> </span><span>image_def</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span> </span><span>p</span><span> </span><span>a</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_FVars</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`suitable pick&#39;`</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>t</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>pp</span><span> </span><span>a</span><span> </span><span>tt</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_FVars</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`suitable pick&#39;`</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_T pk&#39; tt&quot;</span></span></span><span> </span><span>pp</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F (inv v&#39; &#8728; v) (inv v&#39; &#8728; v)
     (&#955;(t, pd) (t&#39;, pd&#39;). alpha (map_T v t) (map_T v&#39; t&#39;) &#8743; mapPC v t pd = mapPC v&#39; t&#39; pd&#39;)
     (&#955;(t, pd) (t&#39;, pd&#39;). alpha (map_T v t) (map_T v&#39; t&#39;) &#8743; mapPC v t pd = mapPC v&#39; t&#39; pd&#39;) X X&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pk</span><span> </span><span>pk&#39;</span><span> </span><span>X_def</span><span> </span><span>X&#39;_def</span><span> </span><span>F_rel_map</span><span> </span><span>suitable_def</span><span> </span><span>v</span><span> </span><span>v&#39;</span><span>
</span><span>              </span><span>supp_comp_bound</span><span> </span><span>supp_inv_bound</span><span> </span><span>Grp_def</span><span> </span><span>OO_def</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F_rel_mono_strong0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>rxx&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pk</span><span> </span><span>pk&#39;</span><span> </span><span>v</span><span> </span><span>v&#39;</span><span> </span><span>u</span><span> </span><span>supp_comp_bound</span><span> </span><span>supp_inv_bound</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>v&#39;</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_X</span><span> </span><span>FVars_X&#39;</span><span> </span><span>imsupp_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>v&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_x_x&#39;</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_ctor</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Int_iff</span><span> </span><span>Un_iff</span><span> </span><span>empty_iff</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>evw</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq_on_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>pk</span><span> </span><span>v&#39;</span><span> </span><span>pk&#39;</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>inv_simp1</span><span> </span><span>pk&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>v&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>tt</span><span> </span><span>tt&#39;</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tt &#8712; set3_F x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tt&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tt&#39; &#8712; set3_F x&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>al</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha tt tt&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T v tt) (map_T v&#39; tt)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>alpha_bij</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span> </span><span>v&#39;</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tt</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_X</span><span> </span><span>FVars_X&#39;</span><span> </span><span>FVars_x_x&#39;</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_ctor</span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>alpha_refl</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Int_iff</span><span> </span><span>UN_I</span><span> </span><span>UnCI</span><span> </span><span>empty_iff</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T v&#39; tt) (map_T v&#39; tt&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_bij_eq</span><span> </span><span>v&#39;</span><span> </span><span>al</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>alv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T v tt) (map_T v&#39; tt&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subshape tt t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set3_F_subshape</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tt</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ss&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subshape tt&#39; t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subshape.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span>id</span><span> </span><span>_</span><span> </span><span>tt</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tt</span><span> </span><span>alpha_sym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>al</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>T_map_id</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subshape (map_T v tt) t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subshape.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv v&quot;</span></span></span><span> </span><span>_</span><span> </span><span>tt</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tt</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>supp_inv_bound</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>T_map_id</span><span> </span><span>alpha_refl</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapPC v tt (f pick tt) = mapPC v&#39; tt&#39; (f pick&#39; tt&#39;)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IHsw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ss</span><span> </span><span>p</span><span> </span><span>v</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>vA</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>IHsw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ss&#39;</span><span> </span><span>p&#39;</span><span> </span><span>v&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>v&#39;A</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vss</span><span> </span><span>p&#39;</span><span> </span><span>alv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>tt</span><span> </span><span>tt&#39;</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tt &#8712; set4_F x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tt&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tt&#39; &#8712; set4_F x&#39;&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>al</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T u tt) tt&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>al&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>al</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>alpha_bij_eq_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars tt&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v (pk a) = v&#39; (pk&#39; (u a))&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; set2_F x&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>evw</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eq_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>aa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVarsB x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>tt</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_ctor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars (ctor x)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>tt</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_ctor</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>pka</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pk a = a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pk</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>a</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_def</span><span> </span><span>imsupp_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>va</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v a = a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>a</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>FVars_X</span><span> </span><span>supp_def</span><span> </span><span>imsupp_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u a &#8712; FVars (ctor x&#39;) - set2_F x&#39;&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>aa</span><span> </span><span>a</span><span> </span><span>u_set2_F</span><span> </span><span>u</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id_on_def</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FVars_x_x&#39;</span><span> </span><span>a</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bij_implies_inject</span><span> </span><span>image_iff</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>pk&#39;a</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pk&#39; (u a) = u a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pk&#39;</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_def</span><span> </span><span>imsupp_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v&#39;a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v&#39; a = a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v&#39;</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>a</span><span> </span><span>False</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>FVars_X&#39;</span><span> </span><span>FVars_x_x&#39;</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>  </span><span>supp_def</span><span> </span><span>imsupp_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ua</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u a = a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>aa</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>v&#39;a</span><span> </span><span>ua</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T (v &#8728; pk) tt) (map_T (v&#39; &#8728; pk&#39; o u) tt)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>alpha_bij</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>v&#39;</span><span> </span><span>pk</span><span> </span><span>pk&#39;</span><span> </span><span>supp_comp_bound</span><span> </span><span>alpha_refl</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T (v&#39; &#8728; pk&#39; o u) tt) (map_T (v&#39; &#8728; pk&#39;) tt&#39;)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>T_map_comp</span><span> </span><span>v&#39;</span><span> </span><span>pk&#39;</span><span> </span><span>u</span><span> </span><span>supp_comp_bound</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>alpha_bij_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>v&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>alpha_bij_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>pk&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>al</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>alv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T v (map_T pk tt)) (map_T v&#39; (map_T pk&#39; tt&#39;))&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>v</span><span> </span><span>v&#39;</span><span> </span><span>pk</span><span> </span><span>pk&#39;</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>pkss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subshape (map_T pk tt) t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subshape.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv pk&quot;</span></span></span><span> </span><span>_</span><span> </span><span>tt</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tt</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pk</span><span> </span><span>supp_inv_bound</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>T_map_id</span><span> </span><span>alpha_refl</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>pkss&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subshape (map_T pk&#39; tt&#39;) t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subshape.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv u o inv pk&#39;&quot;</span></span></span><span> </span><span>_</span><span> </span><span>tt</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tt</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pk&#39;</span><span> </span><span>u</span><span> </span><span>supp_inv_bound</span><span> </span><span>supp_comp_bound</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>                </span><span>o_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>alpha_sym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>al&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv pk &#8728; inv v &#8728; (v &#8728; pk) = id&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>o_assoc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pk</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vpkss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subshape (map_T v (map_T pk tt)) t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>pk</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subshape.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv pk o inv v&quot;</span></span></span><span> </span><span>_</span><span> </span><span>tt</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tt</span><span> </span><span>o_assoc</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pk</span><span> </span><span>v</span><span> </span><span>supp_inv_bound</span><span> </span><span>supp_comp_bound</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>                </span><span>T_map_id</span><span> </span><span>alpha_refl</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mapPC v (map_T pk tt) (f pick (map_T pk tt)) =
                  mapPC v&#39; (map_T pk&#39; tt&#39;) (f pick&#39; (map_T pk&#39; tt&#39;))&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IHsw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>pkss</span><span> </span><span>p</span><span> </span><span>v</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>vA</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>IHsw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>pkss&#39;</span><span> </span><span>p&#39;</span><span> </span><span>v&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>v&#39;A</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IHal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vpkss</span><span> </span><span>p&#39;</span><span> </span><span>alv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f pick t p = f pick&#39; t&#39; p&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span>t&#39;</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span>p&#39;</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pk_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>pk&#39;_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>X_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>X&#39;_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_swap</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u &#8745; A = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f pick (map_T u t) = mapPC u t (f pick t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_swap_alpha</span><span class="delimiter">[</span><span>OF</span><span> </span><span>p</span><span> </span><span>p</span><span> </span><span>u</span><span> </span><span>alpha_refl</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_alpha</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha t t&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f pick t = f pick&#39; t&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij id&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp id| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp id &#8745; A = {}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>emp_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_swap_alpha</span><span class="delimiter">[</span><span>OF</span><span> </span><span>p</span><span> </span><span>p&#39;</span><span> </span><span>u</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*******************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Committing to &#39;particular pick-fresh function: *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pick0</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::var_TT, &#39;a, &#39;a T, &#39;a T) F &#8658; &#39;a P &#8658; &#39;a &#8658; &#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;pick0 &#8801; SOME pick. suitable pick&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exists_suitable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707; pick. suitable pick&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?phi</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955; x p pk. bij pk &#8743;
      |supp pk| &lt;o bound(any::&#39;a::var_TT) &#8743;
      imsupp pk &#8745; (FVars (ctor x) &#8746; FVarsP p &#8746; A - set2_F x) = {} &#8743;
      pk ` set2_F x &#8745; (FVars (ctor x) &#8746; FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a,&#39;a,&#39;a T, &#39;a T)F&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a P&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Sr</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVars (ctor x) &#8746; FVarsP p &#8746; A - set2_F x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S &#8801; set2_F x &#8746; ?Sr &quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|S| &lt;o bound (any::&#39;a::var_TT)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>regularCard_Un</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bound_Card_order</span><span> </span><span>bound_cinfinite</span><span> </span><span>bound_regularCard</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_of_FVars_bound</span><span> </span><span>small_FVarsP</span><span> </span><span>small_A</span><span> </span><span>set2_F_bound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|- S| =o bound (any::&#39;a::var_TT)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>infinite_UNIV_card_of_minus</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SS</span><span> </span><span>Compl_eq_Diff_UNIV</span><span> </span><span>var_TT_infinite</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|set2_F x| &lt;o |- S|&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set2_F_bound</span><span> </span><span>ordIso_symmetric</span><span> </span><span>ordLess_ordIso_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ordLess_imp_ordLeq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>KK</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>KKS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;KK &#8838; - S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>KKo</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|set2_F x| =o |KK|&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>internalize_card_of_ordLeq2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>interl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F x &#8745; KK = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F x &#8745; ?Sr = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;KK &#8745; ?Sr = {}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>KKS</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u &#8745; ?Sr = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw u (set2_F x) KK&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ordIso_ex_bij_betw_supp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>var_TT_infinite</span><span> </span><span>set2_F_bound</span><span> </span><span>KKo</span><span> </span><span>interl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` set2_F x &#8838; KK&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_betw_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>uu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` set2_F x &#8745; (set2_F x &#8746; FVars (ctor x) &#8746; FVarsP p &#8746; A) = {}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>KKS</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707; u. ?phi x p u&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span>uu</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suitable_pick0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>someI_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>exists_suitable</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pick0_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f0 &#8801; f pick0&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alpha_f0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha t t&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f0 t = f0 t&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f0_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>f_alpha</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_pick0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f0_low_level_simps</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;f0 (ctor x) p =
 CTOR (map_F id (pick0 x p)
           (&#955;t. (t, f0 t))
           (&#955;t. (map_T (pick0 x p) t, f0 (map_T (pick0 x p) t))) x) p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f0_def</span><span> </span><span>f_simps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>suitable_pick0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f0_ctor</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Here noclash is needed! *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F x &#8745; (FVarsP p &#8746; A) = {}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;noclash (x::(&#39;a::var_TT, &#39;a, &#39;a T, &#39;a T) F)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f0 (ctor x) p = CTOR (map_F id id (&#955;t. (t, f0 t)) (&#955;t. (t, f0 t)) x) p&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>pick1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;pick1 &#8801; &#955; x&#39; p&#39;. if (x&#39;,p&#39;) = (x,p) then id else pick0 x&#39; p&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_pick0</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span>pick1_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span>noclash_FVars_ctor_int</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick1 x p = id&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pick1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f pick1 (ctor x) = f0 (ctor x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_alpha</span><span class="delimiter">[</span><span>OF</span><span> </span><span>alpha_refl</span><span> </span><span>suitable_pick0</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f pick1 (ctor x) p = CTOR (map_F id id (&#955;t. (t, f0 t)) (&#955;t. (t, f0 t)) x) p&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_simps</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span>2</span><span> </span><span>T_map_id</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>CTOR</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F_map_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>1</span><span> </span><span>suitable_pick0</span><span> </span><span>f0_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>f_alpha</span><span> </span><span>alpha_refl</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>3</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>4</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f0_swap</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u &#8745; A = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f0 (map_T u t) x = mapC u t (f0 t (mapP (inv u) x))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_swap</span><span class="delimiter">[</span><span>OF</span><span> </span><span>suitable_pick0</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>f0_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>mapfn_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>f0_FVars</span><span> </span><span class="delimiter">=</span><span> </span><span>f_FVars</span><span class="delimiter">[</span><span>OF</span><span> </span><span>suitable_pick0</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>f0_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The following theorems for raw theorems will now be lifted to quotiented terms: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>alpha_f0</span><span>
</span><span>  </span><span>f0_ctor</span><span>
</span><span>  </span><span>f0_swap</span><span> </span><span>f0_FVars</span><span>
</span><span>  </span><span>CTOR_alpha</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*******************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* End product: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ff0</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::var_TT TT &#8658; &#39;a P &#8658; &#39;a C&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ff0 t p = f0 (rep_TT t) p&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alpha_f0_par</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha t t&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f0 t p = f0 t&#39; p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_f0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nnoclash_noclash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;nnoclash x &#10231; noclash (map_F id id rep_TT rep_TT x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>noclash_def</span><span> </span><span>nnoclash_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>FFVars_def</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ff0_cctor</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F x &#8745; (FVarsP p &#8746; A) = {}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nnoclash x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ff0 (cctor x) p = CCTOR (map_F id id (&#955;t. (t, ff0 t)) (&#955;t. (t, ff0 t)) x) p&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F x = set2_F (map_F id id rep_TT rep_TT x)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff0_def</span><span> </span><span>cctor_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f0_ctor</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>CTOR_def</span><span class="delimiter">,</span><span>symmetric</span><span class="delimiter">,</span><span>OF</span><span> </span><span>x</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>0</span><span class="delimiter">]</span><span>  </span><span>n</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>nnoclash_noclash</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>o_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>alpha_f0_par</span><span> </span><span>alpha_rep_abs_TT</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ff0_sswap</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp u &#8745; A = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ff0 (map_TT u t) p = mmapC u t (ff0 t (mapP (inv u) p))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;asSS u = u&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>asSS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff0_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f0_swap</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rep_TT t&quot;</span></span></span><span> </span><span>p</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_TT_def</span><span> </span><span>mapC_def</span><span> </span><span>u</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>fun_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span>f_alpha</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>suitable_pick0</span><span> </span><span>suitable_pick0</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>f0_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span>alpha_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>alpha_rep_abs_TT</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>alpha_f0</span><span> </span><span>alpha_rep_abs_TT</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ff0_FFVars</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;FFVarsC t (ff0 t p) &#8838; FFVars t &#8746; FVarsP p &#8746; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f0_FVars</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rep_TT t&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FFVars_def</span><span> </span><span>FVarsC_def</span><span> </span><span>ff0_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>

</div>
</body>
</html>
