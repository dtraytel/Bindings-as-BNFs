<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Labeled_FSet (Isabelle2018: August 2018)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Labeled_FSet</h1>

<span class="command">theory</span> <span class="name">Labeled_FSet</span><br/>
<span class="keyword">imports</span> <a href="Prelim.html"><span class="name">Prelim</span></a> <a href="../../HOL/HOL-Library/FSet.html"><span class="name">FSet</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Labeled_FSet</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;../Prelim&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HOL-Library.FSet&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>nonrep_pair</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#215; &#39;b &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nonrep_pair _ &#8801; True&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>nonrep_fset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a fset &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nonrep_fset _ &#8801; True&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nonrep_lfset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#215; &#39;b) fset &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;nonrep_lfset X = (nonrep_fset X &#8743; (&#8704;x &#8712; fset X. nonrep_pair x) &#8743;
     (&#8704;x &#8712; fset X. &#8704;y &#8712; fset X. x &#8800; y &#10230; Basic_BNFs.fsts x &#8745; Basic_BNFs.fsts y = {}))&quot;</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonrep_lfset_alt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;nonrep_lfset X = (&#8704;a b c. (a, b) |&#8712;| X &#10230;  (a, c) |&#8712;| X &#10230; b = c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nonrep_lfset_def</span><span> </span><span>prod_set_defs</span><span> </span><span>fmember.rep_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="delimiter">(</span><span class="tfree">&#39;a</span><span class="delimiter">,</span><span> </span><span class="tfree">&#39;b</span><span class="delimiter">)</span><span> </span><span>G</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;UNIV :: (&#39;a &#215; &#39;b) fset set&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">copy_bnf</span></span><span> </span><span class="delimiter">(</span><span class="tfree">&#39;a</span><span class="delimiter">,</span><span> </span><span class="tfree">&#39;b</span><span class="delimiter">)</span><span> </span><span>G</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_G</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_G_transfer</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;rel_fun (=) (rel_fun (=) (rel_fun (pcr_G (=) (=)) (pcr_G (=) (=)))) (&#955;f g. (|`|) (map_prod f g)) map_G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Local_Defs.unfold_tac @{context}
      [BNF_Def.bnf_of @{context} @{type_name G} |&gt; the |&gt; BNF_Def.map_def_of_bnf]&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>pcr_G_def</span><span> </span><span>cr_G_def</span><span> </span><span>prod.rel_eq</span><span> </span><span>fset.rel_eq</span><span> </span><span>relcompp_apply</span><span> </span><span>Abs_G_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>nonrep_G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a, &#39;b) G &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>nonrep_lfset</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonrep_G_map</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij f &#10233; nonrep_G x &#10233; nonrep_G (map_G f g x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>f</span><span> </span><span>g</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nonrep_lfset_alt</span><span> </span><span>map_prod_def</span><span> </span><span>fimage_iff</span><span> </span><span>the_inv_f_f</span><span> </span><span>bij_is_inj</span><span>
</span><span>    </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bij_the_inv_revert</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonrep_G_map_fst_snd</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;nonrep_G (map_G f fst x) &#10233; nonrep_G (map_G f snd x) &#10233; nonrep_G (map_G f id x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nonrep_lfset_alt</span><span> </span><span>map_prod_def</span><span> </span><span>image_iff</span><span> </span><span>split_beta</span><span> </span><span>fBex.rep_eq</span><span> </span><span>fmember.rep_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonrep_G_map_fst_snd_bij</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bij f &#10233; nonrep_G (map_G f fst x) &#10233; nonrep_G (map_G f snd x) &#10233; nonrep_G x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nonrep_lfset_alt</span><span> </span><span>map_prod_def</span><span> </span><span>image_iff</span><span> </span><span>split_beta</span><span> </span><span>fBex.rep_eq</span><span> </span><span>fmember.rep_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>large_G</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>dummy</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;a</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>large_G</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bd_G &#8804;o |UNIV :: &#39;a set|&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>nat</span><span> </span><span class="delimiter">::</span><span> </span><span>large_G</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Card_order_iff_ordLeq_card_of</span><span> </span><span>G.bd_card_order</span><span> </span><span>card_order_on_Card_order</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>prod</span><span> </span><span class="delimiter">::</span><span>  </span><span class="delimiter">(</span><span>type</span><span class="delimiter">,</span><span> </span><span>large_G</span><span class="delimiter">)</span><span> </span><span>large_G</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>UNIV_prod</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ordLeq_transitive</span><span class="delimiter">[</span><span>OF</span><span> </span><span>large_G</span><span> </span><span>card_of_Times2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="delimiter">(</span><span class="tfree">&#39;a</span><span class="delimiter">,</span><span> </span><span class="tfree">&#39;b</span><span class="delimiter">)</span><span> </span><span>lfset</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x :: (&#39;a :: large_G, &#39;b) G . nonrep_G x}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mem_Collect_eq</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nonrep_lfset_alt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>map_lfset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a :: large_G &#8658; &#39;a&#39; :: large_G) &#8658; (&#39;b &#8658; &#39;b&#39;) &#8658; (&#39;a, &#39;b) lfset &#8658; (&#39;a&#39;, &#39;b&#39;) lfset&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;map_lfset f g = Abs_lfset o map_G f g o Rep_lfset&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>labels</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a :: large_G, &#39;b) lfset &#8658; &#39;a set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;labels = set1_G o Rep_lfset&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;values&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a :: large_G, &#39;b) lfset &#8658; &#39;b set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;values = set2_G o Rep_lfset&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rel_lfset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a :: large_G &#8658; &#39;a :: large_G) &#8658; (&#39;b &#8658; &#39;b&#39; &#8658; bool) &#8658; (&#39;a, &#39;b) lfset &#8658; (&#39;a, &#39;b&#39;) lfset &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;rel_lfset f S = BNF_Def.vimage2p Rep_lfset Rep_lfset (rel_G (Grp f) S)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>lfset_map_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_lfset id id = id&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>map_lfset_def</span><span> </span><span>G.map_id</span><span> </span><span>fun_eq_iff</span><span> </span><span>o_apply</span><span> </span><span>Rep_lfset_inverse</span><span> </span><span>id_apply</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>lfset_map_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u &#10233; map_lfset (v o u) (f o g) = map_lfset v f o map_lfset u g&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>map_lfset_def</span><span> </span><span>fun_eq_iff</span><span> </span><span>o_apply</span><span> </span><span>simp_thms</span><span> </span><span>G.map_comp</span><span>
</span><span>    </span><span>Abs_lfset_inverse</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">]</span><span> </span><span>nonrep_G_map</span><span> </span><span>Rep_lfset</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>lfset_set1_map</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u &#10233; labels o map_lfset u g = image u o labels&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>labels_def</span><span> </span><span>map_lfset_def</span><span> </span><span>fun_eq_iff</span><span> </span><span>o_apply</span><span> </span><span>simp_thms</span><span> </span><span>G.set_map</span><span>
</span><span>    </span><span>Abs_lfset_inverse</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">]</span><span> </span><span>nonrep_G_map</span><span> </span><span>Rep_lfset</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>lfset_set2_map</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u &#10233; values o map_lfset u g = image g o values&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>values_def</span><span> </span><span>map_lfset_def</span><span> </span><span>fun_eq_iff</span><span> </span><span>o_apply</span><span> </span><span>simp_thms</span><span> </span><span>G.set_map</span><span>
</span><span>    </span><span>Abs_lfset_inverse</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">]</span><span> </span><span>nonrep_G_map</span><span> </span><span>Rep_lfset</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>lfset_map_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a. a &#8712; labels p &#10233; u a = v a&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a. a &#8712; values p &#10233; g a = h a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_lfset u g p = map_lfset v h p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>map_lfset_def</span><span> </span><span>o_apply</span><span> </span><span>labels_def</span><span> </span><span>values_def</span><span> </span><span>assms</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>G.map_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>lfset_set_bd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|labels p| &#8804;o bd_G&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;|values p| &#8804;o bd_G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>labels_def</span><span> </span><span>values_def</span><span> </span><span>o_apply</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>G.set_bd</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>lfset_rel_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;rel_lfset id ((=)) = ((=))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_lfset_def</span><span> </span><span>vimage2p_def</span><span> </span><span>eq_alt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>G.rel_eq</span><span> </span><span>Rep_lfset_inject</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>lfset_in_rel</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bij f &#10233; rel_lfset f R x y = (&#8707;z. values z &#8838; {(x,y). R x y} &#8743; map_lfset id fst z = x &#8743; map_lfset f snd z = y)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_lfset_def</span><span> </span><span>vimage2p_def</span><span> </span><span>G.in_rel</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nonrep_G (map_G fst id z)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Abs_lfset (map_G fst id z)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_lfset_def</span><span> </span><span>values_def</span><span> </span><span>Grp_def</span><span>
</span><span>        </span><span>Abs_lfset_inverse</span><span> </span><span>Rep_lfset</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span>nonrep_G_map</span><span> </span><span>G.set_map</span><span> </span><span>G.map_comp</span><span>
</span><span>        </span><span>G.map_comp</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv f&quot;</span></span></span><span> </span><span>id</span><span> </span><span>snd</span><span> </span><span>snd</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Abs_lfset_inject</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span> </span><span>G.map_cong</span><span> </span><span>nonrep_G_map_fst_snd</span><span>
</span><span>        </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>nonrep_G</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>G.map_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>fst</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv f o snd&quot;</span></span></span><span> </span><span>snd</span><span> </span><span>snd</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span>
</span><span>        </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>nonrep_G</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>z</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_G (&#955;x. (x, f x)) id (Rep_lfset z)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>G.set_map</span><span> </span><span>G.map_comp</span><span> </span><span>Grp_def</span><span> </span><span>values_def</span><span> </span><span>map_lfset_def</span><span> </span><span>Abs_lfset_inverse</span><span> </span><span>Rep_lfset</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span>nonrep_G_map</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>G.map_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>lfset_rel_compp_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;rel_lfset f R OO rel_lfset g S &#8804; rel_lfset (g o f) (R OO S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_lfset_def</span><span> </span><span>G.rel_compp</span><span> </span><span>Grp_o</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vimage2p_relcompp_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>order_refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  unfolding vimage2p_Grp fun_eq_iff relcompp_apply conversep_iff eqTrueI[OF UNIV_I] simp_thms
  apply (safe elim!: GrpE)
  subgoal premises prems for x y _ _ z
  proof (cases z rule: Rep_lfset_cases[unfolded mem_Collect_eq, case_names nonrep_G Rep_lfset])
    case nonrep_G
    with prems(2,5) Rep_lfset[of x] show ?case

      apply (auto simp: G.in_rel Grp_def) find_theorems nonrep_G sorry
  next
    case (Rep_lfset x)
    with prems show ?thesis by (auto simp: Grp_def)
  qed
  done
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* locale+interpretation as a trick to get automatic proofs and replace new constants
   by existing ones afterwards *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>AUX</span><span>
</span><span class="keyword1"><span class="command">lift_bnf</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>AUX</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>dead</span><span> </span><span class="tfree">&#39;a</span><span> </span><span class="delimiter">::</span><span> </span><span>large_G</span><span class="delimiter">,</span><span> </span><span>aux_set_lfset</span><span class="delimiter">:</span><span> </span><span class="tfree">&#39;b</span><span class="delimiter">)</span><span> </span><span>lfset</span><span> </span><span class="delimiter">[</span><span>wits</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Abs_G {||} :: (&#39;a :: large_G, &#39;b) G&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>map</span><span class="delimiter">:</span><span> </span><span>aux_map_lfset</span><span> </span><span>rel</span><span class="delimiter">:</span><span> </span><span>aux_rel_lfset</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nonrep_G.abs_eq</span><span> </span><span>nonrep_lfset_def</span><span> </span><span>Abs_G_inverse</span><span> </span><span>set2_G_def</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">:</span><span> </span><span>nonrep_G_map</span><span> </span><span>nonrep_G_map_fst_snd_bij</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*FIXME for J: problem with tactic in datatype and primrec otherwise*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_lfset_id = map_lfset id&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_lfset_id = rel_lfset id&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>AUX</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">rewrites</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AUX.aux_map_lfset = map_lfset_id&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AUX.aux_rel_lfset = rel_lfset_id&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AUX.aux_set_lfset = values&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Local_Defs.unfold_tac @{context} (@{thms values_def map_lfset_def rel_lfset_def map_lfset_id_def rel_lfset_id_def eq_alt[symmetric]} @
    maps (fn f =&gt; BNF_Def.bnf_of @{context} @{type_name lfset} |&gt; the |&gt; f) [BNF_Def.set_defs_of_bnf,
      single o BNF_Def.map_def_of_bnf, single o BNF_Def.rel_def_of_bnf])&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">qualified</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Rep = Rep_G o Rep_lfset&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">qualified</span></span><span> </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Abs = Abs_lfset o Abs_G&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>type_definition_lfset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;type_definition Rep Abs {X. nonrep_lfset X}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Rep_def</span><span> </span><span>Abs_def</span><span> </span><span>Rep_lfset</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">]</span><span> </span><span>nonrep_G.abs_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span>Rep_G_inverse</span><span> </span><span>Rep_lfset_inverse</span><span> </span><span>Abs_lfset_inverse</span><span> </span><span>Abs_G_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_lfset</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_lfset_id_transfer</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;rel_fun (=) (rel_fun (pcr_lfset (=) (=)) (pcr_lfset (=) (=))) (&#955;g. fimage (map_prod id g)) (map_lfset id)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_fun_def</span><span> </span><span>pcr_lfset_def</span><span> </span><span>cr_lfset_def</span><span> </span><span>prod.rel_eq</span><span> </span><span>fset.rel_eq</span><span> </span><span>eq_OO</span><span> </span><span>map_lfset_def</span><span> </span><span>Rep_def</span><span> </span><span>o_apply</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Abs_lfset_inverse</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Rep_lfset</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span>nonrep_G_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Local_Defs.unfold_tac @{context}
      [BNF_Def.bnf_of @{context} @{type_name G} |&gt; the |&gt; BNF_Def.map_def_of_bnf]&#8250;</span></span></span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Abs_G_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>labels_transfer</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;rel_fun (pcr_lfset (=) (=)) (rel_set (=)) (image fst o fset) labels&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_fun_def</span><span> </span><span>pcr_lfset_def</span><span> </span><span>cr_lfset_def</span><span> </span><span>prod.rel_eq</span><span> </span><span>fset.rel_eq</span><span> </span><span>eq_OO</span><span> </span><span>labels_def</span><span> </span><span>Rep_def</span><span> </span><span>o_apply</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Local_Defs.unfold_tac @{context}
    (BNF_Def.bnf_of @{context} @{type_name G} |&gt; the |&gt; BNF_Def.set_defs_of_bnf)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>rel_set_eq</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>image_eqI</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>values_transfer</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;rel_fun (pcr_lfset (=) (=)) (rel_set (=)) (image snd o fset) values&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_fun_def</span><span> </span><span>pcr_lfset_def</span><span> </span><span>cr_lfset_def</span><span> </span><span>prod.rel_eq</span><span> </span><span>fset.rel_eq</span><span> </span><span>eq_OO</span><span> </span><span>values_def</span><span> </span><span>Rep_def</span><span> </span><span>o_apply</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Local_Defs.unfold_tac @{context}
    (BNF_Def.bnf_of @{context} @{type_name G} |&gt; the |&gt; BNF_Def.set_defs_of_bnf)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>rel_set_eq</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>image_eqI</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_lfset_eq_transfer</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;rel_fun (=) (rel_fun (pcr_lfset (=) (=)) (rel_fun (pcr_lfset (=) (=)) (=))) (&#955;R. rel_fset (rel_prod (=) R)) (rel_lfset id)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_fun_def</span><span> </span><span>pcr_lfset_def</span><span> </span><span>cr_lfset_def</span><span> </span><span>prod.rel_eq</span><span> </span><span>fset.rel_eq</span><span> </span><span>eq_OO</span><span> </span><span>rel_lfset_def</span><span> </span><span>Rep_def</span><span> </span><span>o_apply</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>tactic</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Local_Defs.unfold_tac @{context}
    [BNF_Def.bnf_of @{context} @{type_name G} |&gt; the |&gt; BNF_Def.rel_def_of_bnf]&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>      </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Abs_G_inverse</span><span> </span><span>vimage2p_def</span><span> </span><span>eq_alt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>lfin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#215; &#39;b) &#8658; (&#39;a::large_G, &#39;b) lfset &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8712;&#8712;&quot;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>fmember</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lfin_map_lfset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a, b) &#8712;&#8712; map_lfset id g x &#10231; (&#8707;c. b = g c &#8743; (a, c) &#8712;&#8712; x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lfin_label_inject</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a, b) &#8712;&#8712; x &#10233; (a, c) &#8712;&#8712; x &#10233; b = c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nonrep_lfset_alt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>lfempty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::large_G, &#39;b) lfset&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{||} :: (&#39;a &#215; &#39;b) fset&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nonrep_lfset_alt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>labels_lfempty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;labels lfempty = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>labels_empty_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;labels X = {} &#10231; X = lfempty&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fmember.rep_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>values_lfempty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;values lfempty = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lfin_lfempty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712;&#8712; lfempty = False&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lfin_values</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(l, c) &#8712;&#8712; x &#10233; c &#8712; values x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fmember.rep_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_labels</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (labels x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_values</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (values x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>values_lfin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8712; values x &#10233; &#8707;l. (l, c) &#8712;&#8712; x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fmember.rep_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pred_lfset_lfempty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pred_lfset P lfempty = True&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lfset.pred_set</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>lfinsert</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;b &#8658; (&#39;a::large_G, &#39;b) lfset &#8658; (&#39;a, &#39;b) lfset&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;a b X. if &#8707;c. b &#8800; c &#8743; (a, c) |&#8712;| X then X else finsert (a, b) X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nonrep_lfset_alt</span><span> </span><span>split_beta</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>lfupdate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::large_G, &#39;b) lfset &#8658; &#39;a &#8658; &#39;b &#8658; (&#39;a, &#39;b) lfset&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;X a b. finsert (a, b) (ffilter (&#955;(a&#39;, _). a &#8800; a&#39;) X)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nonrep_lfset_alt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>lfunion</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::large_G, &#39;b) lfset &#8658; (&#39;a, &#39;b) lfset &#8658; (&#39;a, &#39;b) lfset&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;X Y. funion Y (ffilter (&#955;(a, _). a |&#8713;| fst |`| Y) X)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nonrep_lfset_alt</span><span> </span><span>image_iff</span><span> </span><span>fBall.rep_eq</span><span> </span><span>fmember.rep_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">nonterminal</span></span><span> </span><span>lfupdbinds</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lfupdbind</span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_lfupdbind&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a &#8658; lfupdbind&quot;</span></span></span><span>                 </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(2_ :=/ _)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&quot;</span></span></span><span>           </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lfupdbind &#8658; lfupdbinds&quot;</span></span></span><span>               </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_lfupdbinds&quot;</span></span></span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lfupdbind &#8658; lfupdbinds &#8658; lfupdbinds&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_,/ _&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_lfUpdate&quot;</span></span></span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; lfupdbinds &#8658; &#39;a&quot;</span></span></span><span>                </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_/&#10627;(_)&#10628;&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span>900</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_lfUpdate f (_lfupdbinds b bs)&quot;</span></span></span><span> </span><span class="delimiter">&#8652;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_lfUpdate (_lfUpdate f b) bs&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;f&#10627;x:=y&#10628;&quot;</span></span></span><span> </span><span class="delimiter">&#8652;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CONST lfupdate f x y&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Size setup&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>size_lfset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::large_G &#8658; nat) &#8658; (&#39;b &#8658; nat) &#8658; (&#39;a, &#39;b) lfset &#8658; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;f g. size_fset (size_prod f g)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>lfset</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>large_G</span><span class="delimiter">,</span><span>type</span><span class="delimiter">)</span><span> </span><span>size</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>size_lfset</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>size_lfset_overloaded_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;size_lfset = Labeled_FSet.size_lfset (&#955;_. 0) (&#955;_. 0)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>size_lfset_simps</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>size_lfset_def</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>meta_eq_to_obj_eq</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>fun_cong</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>fun_cong</span><span class="delimiter">,</span><span>
</span><span>    </span><span>unfolded</span><span> </span><span>map_fun_def</span><span> </span><span>comp_def</span><span> </span><span>id_apply</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>size_lfset_overloaded_simps</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>size_lfset_simps</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;_. 0&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;_. 0&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>add_0_left</span><span> </span><span>add_0_right</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>size_lfset_overloaded_def</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lfset_size_o_map</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;inj f &#10233; size_lfset (&#955;_. 0) g &#8728; map_lfset_id f = size_lfset (&#955;_. 0) (g &#8728; f)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fun_eq_iff</span><span> </span><span>o_apply</span><span> </span><span>map_lfset_id_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span>
</span><span>    </span><span class="delimiter">(</span><span>subst</span><span> </span><span>fun_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fset_size_o_map</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>o_apply</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>split_beta</span><span> </span><span>map_prod_def</span><span> </span><span>size_prod_simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
BNF_LFP_Size.register_size_global @{type_name lfset} @{const_name size_lfset}
  @{thm size_lfset_overloaded_def} @{thms size_lfset_simps size_lfset_overloaded_simps}
  @{thms lfset_size_o_map}
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_fset_estimation</span><span class="delimiter">[</span><span>termination_simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; fset X &#10233; y &lt; f x &#10233; y &lt; size_fset f X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>order.strict_trans2</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">:</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>member_le_sum</span><span> </span><span>ordered_comm_monoid_add_class.sum_mono</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_fset_estimation&#39;</span><span class="delimiter">[</span><span>termination_simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; fset X &#10233; y &#8804; f x &#10233; y &#8804; size_fset f X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>order_trans</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">:</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>member_le_sum</span><span> </span><span>ordered_comm_monoid_add_class.sum_mono</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_lfset_estimation</span><span class="delimiter">[</span><span>termination_simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; values X &#10233; y &lt; f x &#10233; y &lt; size_lfset (&#955;_. 0) f X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>size_fset_simps</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>size_fset_estimation</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>size_lfset_estimation&#39;</span><span class="delimiter">[</span><span>termination_simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; values X &#10233; y &#8804; f x &#10233; y &#8804; size_lfset (&#955;_. 0) f X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>size_fset_simps</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>size_fset_estimation&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>apply_lfset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::large_G, &#39;b &#8658; &#39;c) lfset &#8658; (&#39;a, &#39;b) lfset &#8658; (&#39;a, &#39;c) lfset&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;F X. if fst |`| F |&#8838;| fst |`| X then (&#955;(a, f). (a, f (THE b. (a, b) |&#8712;| X))) |`| F else {||}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nonrep_lfset_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lfin_apply_lfset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;labels F &#8838; labels X &#10233;
  (a, fx) &#8712;&#8712; apply_lfset F X &#10231; (&#8707;f x. fx = f x &#8743; (a, f) &#8712;&#8712; F &#8743; (a, x) &#8712;&#8712; X)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fmember.rep_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>F</span><span> </span><span>X</span><span> </span><span>a</span><span> </span><span>f</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>set_mp</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a&#39;</span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>the1_equality</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nonrep_lfset_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>F</span><span> </span><span>X</span><span> </span><span>a</span><span> </span><span>f</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>image_eqI</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>the1_equality</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nonrep_lfset_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lifting_update</span></span><span> </span><span>lfset.lifting</span><span>
</span><span class="keyword1"><span class="command">lifting_forget</span></span><span> </span><span>lfset.lifting</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>fun_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lfset_size_o_map</span><span class="delimiter">,</span><span> 
</span><span>unfolded</span><span> </span><span>id_def</span><span> </span><span>inj_on_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">,</span><span> </span><span>termination_simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_fact</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>FSet.bex_simps</span><span> </span><span>FSet.ball_simps</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>

</div>
</body>
</html>
