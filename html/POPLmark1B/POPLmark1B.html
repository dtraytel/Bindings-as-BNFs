<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory POPLmark1B (Isabelle2018: August 2018)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory POPLmark1B</h1>

<span class="command">theory</span> <span class="name">POPLmark1B</span><br/>
<span class="keyword">imports</span> <a href="Custom_POPLmark1B.html"><span class="name">Custom_POPLmark1B</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>POPLmark1B</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Custom_POPLmark1B</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;swap x y z = (if x = z then y else if y = z then x else z)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swap_itself</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;swap x x = id&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>swap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>     
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bij_swap</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (swap x y)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>o_bij</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;swap x y&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>swap_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supp_swap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;supp (swap x y) = (if x = y then {} else {x, y})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>supp_def</span><span> </span><span>swap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>imsupp_swap</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;imsupp (swap x y) = (if x = y then {} else {x, y})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span>swap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supp_swap_bound</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp (swap x y)| &#8804;o bound(any::&#39;a::var_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_swap</span><span> </span><span>bound_cinfinite</span><span> </span><span>bound_Card_order</span><span> </span><span>cfinite_def</span><span> </span><span>ordLess_imp_ordLeq</span><span> </span><span>Cfinite_ordLess_Cinfinite</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_supp_swap</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (supp (swap x y))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_swap</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swap_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;swap x y a = y &#10231; a = x&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;swap x y a = x &#10231; a = y&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;y = swap x y a &#10231; a = x&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x = swap x y a &#10231; a = y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>swap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swap_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8800; a &#10233; y &#8800; a &#10233; swap x y a = a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>swap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swap_swap</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;swap x y o swap y x = id&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;swap x y o swap x y = id&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>swap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* For POPLmarkTypes: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vvsubst_id2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;vvsubst id = id&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vvsubst_id</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vvsubst_comp</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;finite (supp g) &#10233; finite (supp f) &#10233; 
   vvsubst (g &#8728; f) = vvsubst g o vvsubst f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vvsubst_o</span><span class="delimiter">[</span><span>of</span><span> </span><span>g</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span>finite_less_bound</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;supp g&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>finite_less_bound</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;supp f&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;a</span><span> </span><span>ctxt</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#215; &#39;a TT) list&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;vars_ctxt &#915; &#8801; fst ` set &#915; &#8746; &#8899;(FFVars ` snd ` set &#915;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_FFVars</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (FFVars (T :: &#39;a::var_TT TT))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>T</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>user_TT_plain_induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>finite_bound</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>bound_cinfinite</span><span> </span><span>bound_Card_order</span><span> </span><span>cfinite_def</span><span>
</span><span>        </span><span>ordLess_imp_ordLeq</span><span> </span><span>Cfinite_ordLess_Cinfinite</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>wf_type</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::{large_G, var_TT} ctxt &#8658; &#39;a TT &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">]</span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>wf_type_FFVars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T &#10231; FFVars T &#8838; fst ` set &#915;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>wf_ctxt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::{large_G, var_TT} ctxt &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>51</span><span class="delimiter">]</span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>WF_Nil</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> []&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>WF_Cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915; &#10233; x &#8713; fst ` set &#915; &#10233; &#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T &#10233; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> (x, T) # &#915;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>wf_ctxt.intros</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>wf_ctxtE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> X # &#915;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>subtyping</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::{large_G, var_TT} ctxt &#8658; &#39;a TT &#8658; &#39;a TT &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ &#8866; _ &lt;: _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">]</span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>SA_TTop</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915; &#10233; &#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T &#10233; &#915; &#8866; T &lt;: TTop&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>SA_TVar_Refl</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915; &#10233; X &#8712; fst ` set &#915; &#10233; &#915; &#8866; TVar X &lt;: TVar X&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>SA_TVar_Trans</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(X, U) &#8712; set &#915; &#10233; &#915; &#8866; U &lt;: T &#10233; &#915; &#8866; TVar X &lt;: T&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>SA_TArr</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; T1 &lt;: S1 &#10233; &#915; &#8866; S2 &lt;: T2 &#10233; &#915; &#8866; TArr S1 S2 &lt;: TArr T1 T2&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>SA_TAll</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; T1 &lt;: S1 &#10233; x &#8713; fst ` set &#915; &#10233; (x, T1) # &#915; &#8866; S2 &lt;: T2 &#10233; &#915; &#8866; TAll x S1 S2 &lt;: TAll x T1 T2&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>SA_TRec</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915; &#10233; &#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> TRec X &#10233; labels X &#8838; labels Y &#10233; (&#8896;x T. (x, T) &#8712;&#8712; Y &#10233; &#8707;S. (x, S) &#8712;&#8712; X &#8743; &#915; &#8866; S &lt;: T) &#10233;
                          &#915; &#8866; TRec X &lt;: TRec Y&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span>
</span><span>  </span><span>subtyping_TVarRE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; S &lt;: TVar X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>subtyping_TTopRE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; S &lt;: TTop&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>subtyping_TArrRE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; S &lt;: TArr T U&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>subtyping_TAllRE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; S &lt;: TAll x T U&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>subtyping_TRecRE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; S &lt;: TRec X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>subtyping_TVarLE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; TVar X &lt;: S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>subtyping_TTopLE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; TTop &lt;: S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>subtyping_TArrLE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; TArr T U &lt;: S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>subtyping_TAllLE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; TAll x T U &lt;: S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>subtyping_TRecLE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; TRec X &lt;: S&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Crucial well-scoping property: No loose variables. *)</span></span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subtyping_wf_ctxt</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; T &lt;: U &#10233; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>&#915;</span><span> </span><span>T</span><span> </span><span>U</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>subtyping.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subtyping_wf_type</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; T &lt;: U &#10233; &#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T &#8743; &#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> U&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>&#915;</span><span> </span><span>T</span><span> </span><span>U</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>subtyping.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_type_FFVars</span><span> </span><span>image_iff</span><span> </span><span>subset_eq</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>values_lfin</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Invariance under bijective subsitution:   *)</span></span></span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vvsubst_wf_type</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bij f &#10233; finite (supp f) &#10233; &#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T &#10233; 
   map (map_prod f (vvsubst f)) &#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> vvsubst f T&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_type_FFVars</span><span> </span><span>image_image</span><span> </span><span>FFVars_vvsubst</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vvsubst_wf_ctxt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915; &#10233; bij f &#10233; finite (supp f) &#10233; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> map (map_prod f (vvsubst f)) &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>&#915;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>wf_ctxt.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vvsubst_wf_type</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subtyping_vvsubst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; T &lt;: U&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij f&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (supp f)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (map_prod f (vvsubst f)) &#915; &#8866; vvsubst f T &lt;: vvsubst f U&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>&#915;</span><span> </span><span>T</span><span> </span><span>U</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>subtyping.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>3</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vvsubst_wf_ctxt</span><span> </span><span>lfin_map_lfset</span><span> </span><span>wf_type_FFVars</span><span> </span><span>FFVars_vvsubst</span><span>
</span><span>    </span><span>o_eq_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lfset_set1_map</span><span class="delimiter">]</span><span> </span><span>o_eq_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lfset_set2_map</span><span class="delimiter">]</span><span> </span><span>image_image</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  ... and in particular under swapping: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;vvswap x y &#8801; vvsubst (swap x y)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;swap_ctxt x y &#8801; map (map_prod (swap x y) (vvswap x y))&quot;</span></span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FFVars_vvswap</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FFVars (vvswap x y t) = {swap x y z |z. z &#8712; FFVars t}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>FFVars_vvsubst</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swap_same</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;swap x x&#39; x = x&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>swap_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vvswap_idle</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; FFVars T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; &#8713; FFVars T&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;vvswap x&#39; x T = T&quot;</span></span></span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;vvswap x&#39; x T = vvsubst id T&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>vvsubst_cong</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>swap_def</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_ctxt_snd_fst</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915;&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899; (FFVars ` snd ` set &#915;) &#8838; fst ` set &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induction</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_type_FFVars</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swap_ctxt_idle</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; fst ` set &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; &#8899; (FFVars ` snd ` set &#915;)&quot;</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; &#8713; fst ` set &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; &#8713; &#8899; (FFVars ` snd ` set &#915;)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;swap_ctxt x x&#39; &#915; = &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>&#915;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>swap_def</span><span class="delimiter">)</span><span> 
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swap_wf_ctxt_idle</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; fst ` set &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; &#8713; fst ` set &#915;&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;swap_ctxt x x&#39; &#915; = &#915;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_ctxt_snd_fst</span><span class="delimiter">[</span><span>OF</span><span> </span><span>g</span><span class="delimiter">]</span><span> </span><span>swap_ctxt_idle</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x</span><span> </span><span>_</span><span> </span><span>x&#39;</span><span class="delimiter">]</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vvswap_wf_type</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T &#10233; swap_ctxt x y &#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> vvswap x y T&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vvsubst_wf_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bij_swap</span><span> </span><span>finite_supp_swap</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vvswap_wf_ctxt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915; &#10233; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> swap_ctxt x y &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vvsubst_wf_ctxt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>bij_swap</span><span> </span><span>finite_supp_swap</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subtyping_vvswap</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; T &lt;: U &#10233; 
 map (map_prod (swap x y) (vvsubst (swap x y))) &#915; &#8866; vvsubst (swap x y) T &lt;: vvsubst (swap x y) U&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subtyping_vvsubst</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>bij_swap</span><span> </span><span>finite_supp_swap</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>    
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Fresh induction infrastructure: *)</span></span></span></span></span><span>
</span><span>    
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* First equivariance closure *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cl &#966; &#915; T U &#961; = (&#8704; f. bij f &#8743; finite (supp f) &#10230; 
      &#966; (map (map_prod f (vvsubst f)) &#915;) (vvsubst f T) (vvsubst f U) &#961;)&quot;</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>clI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>iffD2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cl_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>clE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cl &#966; &#915; T U &#961;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij f&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (supp f)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#966; (map (map_prod f (vvsubst f)) &#915;) (vvsubst f T) (vvsubst f U) &#961;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>clE_vvswap</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cl &#966; &#915; T U &#961;&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#966; (map (map_prod (swap x y) (vvsubst (swap x y))) &#915;) (vvswap x y T) (vvswap x y U) &#961;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>clE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij_swap</span><span> </span><span>finite_supp_swap</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cl_ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cl &#966; &#915; T U &#961; &#10233; &#966; &#915; T U &#961;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>allE</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>id</span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_id</span><span class="delimiter">)</span><span> 
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cl_vvsubst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij f&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (supp f)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cl &#966; &#915; T U &#961;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cl &#966; (map (map_prod f (vvsubst f)) &#915;) (vvsubst f T) (vvsubst f U) &#961;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cl_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g</span><span> 
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>finite_supp_comp</span><span> </span><span>map_prod.comp</span><span> </span><span>vvsubst_comp</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>allE</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g o f&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cl_cl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cl (cl &#966;) = cl &#966;&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cl_def</span><span> </span><span>cl_ext</span><span> </span><span>cl_vvsubst</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_obtains</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (A::&#39;a::{large_G,var_TT} set)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|A| &lt;o |UNIV::&#39;a set|&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>finite_ordLess_infinite2</span><span> </span><span>var_TT_infinite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>ex_new_if_finite</span><span> </span><span>var_TT_infinite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> 
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* .. then the induction principle statement: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>subtyping_fresh_induct_param</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>2</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>SA_TTop</span><span> </span><span>SA_TVar_Refl</span><span> </span><span>SA_TVar_Trans</span><span> </span><span>SA_TArr</span><span> </span><span>SA_TAll</span><span> </span><span>SA_TRec</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>T</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::{large_G,var_TT} TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;p &#8658; &#39;a set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#961;. finite (K &#961;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Gam</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; U &lt;: T&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>TTop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;&#915; T &#961;. &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915; &#10233; &#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T &#10233; &#966; &#915; T TTop &#961;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>TVar_Refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;&#915; X &#961;. &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915; &#10233; X &#8712; fst ` set &#915; &#10233; &#966; &#915; (TVar X) (TVar X) &#961;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>TVar_Trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;X U &#915; T &#961;. (X, U) &#8712; set &#915; &#10233; &#915; &#8866; U &lt;: T &#10233; (&#8896;&#961;. &#966; &#915; U T &#961;) &#10233; &#966; &#915; (TVar X) T &#961;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>TArr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;&#915; T1 S1 S2 T2 &#961;.
            &#915; &#8866; T1 &lt;: S1 &#10233; (&#8896;&#961;. &#966; &#915; T1 S1 &#961;) &#10233; &#915; &#8866; S2 &lt;: T2 &#10233; (&#8896;&#961;. &#966; &#915; S2 T2 &#961;) &#10233; &#966; &#915; (TArr S1 S2) (TArr T1 T2) &#961;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>TAll</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;&#915; T1 S1 x S2 T2 &#961;.
            (* the only difference from subtyping.induct: *)x &#8713; K &#961; &#10233;
            &#915; &#8866; T1 &lt;: S1 &#10233;
            (&#8896;&#961;. &#966; &#915; T1 S1 &#961;) &#10233; x &#8713; fst ` set &#915; &#10233; (x, T1) # &#915; &#8866; S2 &lt;: T2 &#10233; (&#8896;&#961;. &#966; ((x, T1) # &#915;) S2 T2 &#961;) &#10233; &#966; &#915; (TAll x S1 S2) (TAll x T1 T2) &#961;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>TRec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;&#915; X Y &#961;. &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915; &#10233;
                  &#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> TRec X &#10233;
                  labels X &#8838; labels Y &#10233;
                  (&#8896;x T. (x, T) &#8712;&#8712; Y &#10233; &#8707;S. (x, S) &#8712;&#8712; X &#8743; &#915; &#8866; S &lt;: T &#8743; (&#8704;&#961;. &#966; &#915; S T &#961;)) &#10233; &#966; &#915; (TRec X) (TRec Y) &#961;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;All (&#966; &#915; U T)&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>&#961;</span><span class="delimiter">::</span><span class="tfree">&#39;p</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Gam</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cl &#966; &#915; U T &#961;&quot;</span></span></span><span>  
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>&#961;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>subtyping.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SA_TAll</span><span> </span><span>&#915;</span><span> </span><span>T1</span><span> </span><span>S1</span><span> </span><span>x</span><span> </span><span>S2</span><span> </span><span>T2</span><span> </span><span>&#961;</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>cs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>clI</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span> 
</span><span>       </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; _&quot;</span></span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij f&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (supp f)&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; FFVars S1 &#8746; FFVars T1 &#8746; fst ` set &#915;&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>subtyping_wf_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_type_FFVars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x} &#8746; vars_ctxt &#915; &#8746; FFVars S1 &#8746; FFVars S2 &#8746; 
        FFVars T1 &#8746; FFVars T2 &#8746; imsupp f &#8746; K &#961;&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite ?A&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_FFVars</span><span> </span><span>f</span><span> </span><span>fin</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>finite_UnI</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; &#8713; ?A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_obtains</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>       </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>S2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S2&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S2&#39; = vvsubst (swap x x&#39;) S2&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>T2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>T2&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T2&#39; = vvsubst (swap x x&#39;) T2&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TAll x S1 S2 = TAll x&#39; S1 S2&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TAll x T1 T2 = TAll x&#39; T1 T2&#39;&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S2&#39;</span><span> </span><span>T2&#39;</span><span> </span><span>TAll_inject</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x&#39;</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vusubst_def</span><span> </span><span>supp_id_upd</span><span> </span><span>swap_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vvsubst_cong</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subtyping_wf_ctxt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;swap_ctxt x x&#39; &#915; = &#915;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>swap_wf_ctxt_idle</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f x&#39; = x&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cl_cl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; &#961;. cl (cl &#966;) ((x, T1) # &#915;) S2 T2 &#961;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cs</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cl_cl</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>       </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#966; (map (map_prod f (vvsubst f)) &#915;) (vvsubst f (TAll x S1 S2))
             (vvsubst f (TAll x T1 T2)) &#961;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>0</span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>x&#39;</span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>TAll</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_def</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subtyping_vvsubst</span><span> </span><span>cs</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>clE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cs</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subtyping_vvsubst</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subtyping_vvswap</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cs</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span class="delimiter">]</span><span> </span><span>f</span><span class="delimiter">]</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S2&#39;</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>T2&#39;</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>  
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>clE_vvswap</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cl_cl</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>x</span><span> </span><span>x&#39;</span><span class="delimiter">]</span><span> </span><span>f</span><span class="delimiter">]</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S2&#39;</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>T2&#39;</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SA_TRec</span><span> </span><span>&#915;</span><span> </span><span>X</span><span> </span><span>Y</span><span> </span><span>&#961;</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>clI</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>vvsubst_wf_ctxt</span><span> </span><span>vvsubst_wf_type</span><span> 
</span><span>               </span><span>subtyping_vvsubst</span><span> </span><span>clE</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#966;</span><span class="delimiter">]</span><span>
</span><span>           </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lfset_set1_map</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>o_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>           </span><span>lfin_map_lfset</span><span>
</span><span>     </span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>vvsubst_wf_type</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>subtyping_vvsubst</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>clI</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>vvsubst_wf_ctxt</span><span> </span><span>vvsubst_wf_type</span><span> 
</span><span>               </span><span>subtyping_vvsubst</span><span> </span><span>clE</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#966;</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>cl_ext</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>subtyping_fresh_induct</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>2</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>SA_TTop</span><span> </span><span>SA_TVar_Refl</span><span> </span><span>SA_TVar_Trans</span><span> </span><span>SA_TArr</span><span> </span><span>SA_TAll</span><span> </span><span>SA_TRec</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite K&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; U &lt;: T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;&#915; T. &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915; &#10233; &#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T &#10233; &#966; &#915; T TTop&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;&#915; X. &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915; &#10233; X &#8712; fst ` set &#915; &#10233; &#966; &#915; (TVar X) (TVar X)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;X U &#915; T. (X, U) &#8712; set &#915; &#10233; &#915; &#8866; U &lt;: T &#10233; &#966; &#915; U T &#10233; &#966; &#915; (TVar X) T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;&#915; T1 S1 S2 T2.
            &#915; &#8866; T1 &lt;: S1 &#10233; &#966; &#915; T1 S1 &#10233; &#915; &#8866; S2 &lt;: T2 &#10233; &#966; &#915; S2 T2 &#10233; &#966; &#915; (TArr S1 S2) (TArr T1 T2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;&#915; T1 S1 x S2 T2.
            (* the only difference from subtyping.induct: *)x &#8713; K &#8746; vars_ctxt &#915; &#8746; FFVars S1 &#8746; FFVars T1 &#10233;
            &#915; &#8866; T1 &lt;: S1 &#10233;
            &#966; &#915; T1 S1 &#10233; x &#8713; fst ` set &#915; &#10233; (x, T1) # &#915; &#8866; S2 &lt;: T2 &#10233; &#966; ((x, T1) # &#915;) S2 T2 &#10233; &#966; &#915; (TAll x S1 S2) (TAll x T1 T2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;&#915; X Y. &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915; &#10233;
                  &#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> TRec X &#10233;
                  labels X &#8838; labels Y &#10233;
                  (&#8896;x T. (x, T) &#8712;&#8712; Y &#10233; &#8707;S. (x, S) &#8712;&#8712; X &#8743; &#915; &#8866; S &lt;: T &#8743; &#966; &#915; S T) &#10233; &#966; &#915; (TRec X) (TRec Y)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#966; &#915; U T&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite K&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#961;. finite (case &#961; of (&#915;, U, T) &#8658; K &#8746; vars_ctxt &#915; &#8746; FFVars U &#8746; FFVars T)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#915; &#8866; U &lt;: T&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#961;. &#961; = (&#915;, U, T) &#10230; &#966; &#915; U T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>subtyping_fresh_induct_param</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span>-</span><span>8</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>subtyping_fresh_cases</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>2</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>SA_TTop</span><span> </span><span>SA_TVar_Refl</span><span> </span><span>SA_TVar_Trans</span><span> </span><span>SA_TArr</span><span> </span><span>SA_TAll</span><span> </span><span>SA_TRec</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a :: {large_G, var_TT} TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite K&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#916; &#8866; P &lt;: Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span>
</span><span>    </span><span>&#915;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#215; &#39;a TT) list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#916; = &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P = T&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q = TTop&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span>&#915;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#215; &#39;a TT) list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#916; = &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P = TVar X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q = TVar X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; fst ` set &#915;&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#915;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#215; &#39;a TT) list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#916; = &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;P = TVar X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q = T&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(X, U) &#8712; set &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; U &lt;: T&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span>&#915;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#215; &#39;a TT) list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>T2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#916; = &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P = TArr S1 S2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q = TArr T1 T2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; T1 &lt;: S1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; S2 &lt;: T2&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span>&#915;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#215; &#39;a TT) list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>T2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; K &#8746; vars_ctxt &#915; &#8746; FFVars S1 &#8746; FFVars T1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#916; = &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;P = TAll x S1 S2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q = TAll x T1 T2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; T1 &lt;: S1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; fst ` set &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x, T1) # &#915; &#8866; S2 &lt;: T2&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span>&#915;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#215; &#39;a TT) list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nat, &#39;a TT) lfset&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Y</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nat, &#39;a TT) lfset&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#916; = &#915;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P = TRec X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q = TRec Y&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> TRec X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;labels X &#8838; labels Y&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x T. (x, T) &#8712;&#8712; Y &#10233; &#8707;S. (x, S) &#8712;&#8712; X &#8743; &#915; &#8866; S &lt;: T&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>atomize_elim</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>subtyping_fresh_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SA_TRec</span><span> </span><span>&#915;</span><span> </span><span>X</span><span> </span><span>Y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>metis</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>TAll_inject</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>induct_simp</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span>
</span><span>  </span><span>subtyping_TAllE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; TAll x T U &lt;: TAll x T&#39; U&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>subtyping_fresh_TAllLE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>T</span><span> </span><span>U</span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::{large_G,var_TT} TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite K&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; TAll x T U &lt;: S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S = TTop&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> TAll x T U&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>T1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8713; K &#8746; vars_ctxt &#915; &#8746; FFVars S1 &#8746; FFVars T1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TAll x T U = TAll y S1 S2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;S = TAll y T1 T2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; T1 &lt;: S1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8713; fst ` set &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(y, T1) # &#915; &#8866; S2 &lt;: T2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subtyping_fresh_cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>REFLEXIVITY</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; T &lt;: T&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#915;. |fst ` set &#915;| &lt;o bound(any :: &#39;a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#915;. &#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T &#10230; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915; &#10230; &#915; &#8866; T &lt;: T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>T</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>user_TT_fresh_induct_param_UNIV</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lfin_values</span><span> </span><span>wf_type_FFVars</span><span> </span><span>Diff_single_insert</span><span> </span><span>WF_Cons</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ctxt_weaken &#915; &#916; = (&#8704;x T. (x, T) &#8712; set &#915; &#10230; (x, T) &#8712; set &#916;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ctxt_weakenE</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ctxt_weaken &#915; &#916; &#10233; (x, T) &#8712; set &#915; &#10233; (x, T) &#8712; set &#916;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ctxt_weaken_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_type_ctxt_weaken</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T &#10233; ctxt_weaken &#915; &#916; &#10233; &#916; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ctxt_weaken_def</span><span> </span><span>wf_type_FFVars</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_type_replace</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T &#10233; list_all2 (rel_prod (=) top) &#915; &#916; &#10233; &#916; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_type_FFVars</span><span> </span><span>list.in_rel</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_ctxt_replace</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#916; @ (x, T) # &#915; &#10233; &#915; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> T&#39; &#10233; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#916; @ (x, T&#39;) # &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>&#916;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>wf_ctxtE</span><span> </span><span>wf_type_replace</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_all2_append</span><span> </span><span>image_Un</span><span> </span><span>rev_image_eqI</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>list_all2_refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subtyping_ctxt_weaken</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; T &lt;: U&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#916;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ctxt_weaken &#915; &#916;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#916; &#8866; T &lt;: U&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#916;. finite (fst ` set &#916;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#915; &#8866; T &lt;: U&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#916;. &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#916; &#10230; ctxt_weaken &#915; &#916; &#10230; &#916; &#8866; T &lt;: U&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>&#915;</span><span> </span><span>T</span><span> </span><span>U</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>subtyping_fresh_induct_param</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SA_TAll</span><span> </span><span>&#915;</span><span> </span><span>T1</span><span> </span><span>S1</span><span> </span><span>x</span><span> </span><span>S2</span><span> </span><span>T2</span><span> </span><span>&#916;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SA_TAll</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#916;</span><span class="delimiter">]</span><span> </span><span>SA_TAll</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x, T1) # &#916;&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>wf_ctxt.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>SA_TAll</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ctxt_weaken_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prepend_ctxt_weaken</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#916; @ &#915; &#10233; ctxt_weaken &#915; (&#916; @ &#915;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>&#916;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>&#915;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ctxt_weaken_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WEAKENING</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; S &lt;: T &#10233; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#916; @ &#915; &#10233; &#916; @ &#915; &#8866; S &lt;: T&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subtyping_ctxt_weaken</span><span> </span><span>prepend_ctxt_weaken</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_ctxt_suffix</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#916; @ &#915; &#10233; &#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>&#916;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>&#915;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>wf_ctxtE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>narrowing_from_transitivity</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;&#915; S T. &#915; &#8866; S &lt;: Q &#10233; &#915; &#8866; Q &lt;: T &#10233; &#915; &#8866; S &lt;: T)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#916; @ (x, Q) # &#915; &#8866; M &lt;: N &#10233; &#915; &#8866; P &lt;: Q &#10233; &#916; @ (x, P) # &#915; &#8866; M &lt;: N&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#916; @ (x, Q) # &#915;&quot;</span></span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>&#916;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>subtyping.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SA_TVar_Trans</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>T</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>WEAKENING</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x, P) # &#915;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TVar x&quot;</span></span></span><span> </span><span>Q</span><span> </span><span>&#916;</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>trans</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>        </span><span>subtyping.SA_TVar_Trans</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>WEAKENING</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(x, P)]&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span>  </span><span>subtyping_wf_ctxt</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>wf_ctxt_suffix</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#916;</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>wf_ctxtE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>2</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>wf_type_replace</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>list_all2_refl</span><span>
</span><span>  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_all2_append</span><span> </span><span>subtyping_wf_type</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TAll_rename</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8713; FFVars U &#10233; TAll x T U = TAll y T (vvsubst (swap x y) U)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>TAll_inject</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>FFVars_vvsubst</span><span> </span><span>supp_id_upd</span><span> </span><span>swap_def</span><span> </span><span>vusubst_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vvsubst_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vvswap_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; FFVars R &#10233; y &#8713; FFVars R &#10233; vvswap x y R = R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>swap_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vvsubst_cong</span><span> </span><span>vvsubst_id</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>swap_ctxt_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; vars_ctxt &#915; &#10233; y &#8713; vars_ctxt &#915; &#10233; swap_ctxt x y &#915; = &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>&#915;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vvswap_id</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subtyping_vvswap_fresh</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x, R) # &#915; &#8866; T &lt;: U&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fresh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; vars_ctxt &#915; &#8746; FFVars R&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8713; vars_ctxt &#915; &#8746; FFVars R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(y, R) # &#915; &#8866; vvsubst (swap x y) T &lt;: vvsubst (swap x y) U&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subtyping_vvswap</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span>fresh</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>swap_def</span><span> </span><span>vvswap_id</span><span> </span><span>swap_ctxt_id</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TRANSITIVITY</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; S &lt;: Q&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; Q &lt;: T&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; S &lt;: T&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#961;. |case &#961; of (&#915;::&#39;a ctxt, S::&#39;a TT, T::&#39;a TT) &#8658; vars_ctxt &#915; &#8746; FFVars S &#8746; FFVars T| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#961;. case &#961; of (&#915;, S, T) &#8658; &#915; &#8866; S &lt;: Q &#10230; &#915; &#8866; Q &lt;: T &#10230; &#915; &#8866; S &lt;: T&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>user_TT_fresh_induct_param_UNIV</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bd</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span> </span><span>TVar</span><span> </span><span>TArr</span><span> </span><span>TAll</span><span> </span><span>TRec</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>TVar</span><span> </span><span>y</span><span> </span><span>&#915;</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>TVar</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>&#915;</span><span> </span><span>S</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TVar y&quot;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>TArr</span><span> </span><span>T1</span><span> </span><span>U1</span><span> </span><span>&#915;</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>TArr</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>&#915;</span><span> </span><span>S</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TArr T1 U1&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>4</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wf_type_FFVars</span><span> </span><span>image_iff</span><span> </span><span>Bex_def</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>subtyping_wf_type</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>TArr</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>TAll</span><span> </span><span>y</span><span> </span><span>T1</span><span> </span><span>U1</span><span> </span><span>&#915;</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite {y}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>TAll</span><span class="delimiter">(</span><span>7</span><span class="delimiter">,</span><span>8</span><span class="delimiter">,</span><span>3</span><span>-</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>&#915;</span><span> </span><span>S</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TAll y T1 U1&quot;</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>subtyping_fresh_induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>FFVars_vvsubst</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SA_TAll</span><span> </span><span>&#915;</span><span> </span><span>T1&#39;</span><span> </span><span>L1</span><span> </span><span>x</span><span> </span><span>L2</span><span> </span><span>U1&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U1 = vvswap x y U1&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T1&#39; = T1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8800; y&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; FFVars U1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; FFVars L1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; FFVars T1&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;U. (x, U) &#8713; set &#915;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;y U. (y, U) &#8712; set &#915; &#10233; x &#8713; FFVars U&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8713; FFVars L1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8713; FFVars L2&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8713; FFVars T&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8713; FFVars U1&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;U. (y, U) &#8713; set &#915;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;z U. (z, U) &#8712; set &#915; &#10233; y &#8713; FFVars U&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>2</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_iff</span><span> </span><span>vusubst_def</span><span> </span><span>supp_id_upd</span><span> </span><span>swap_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vvsubst_cong</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SA_TAll</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>subtyping_fresh_TAllLE</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x,y}&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T = TTop&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8866;<span class="hidden">&#8681;</span><sub>w</sub><span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>T</sub> &#915;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; TAll x L1 L2 &lt;: T&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SA_TAll</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span>subtyping_wf_type</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>R1</span><span> </span><span>S1</span><span> </span><span>z</span><span> </span><span>S2</span><span> </span><span>R2</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T = TAll z R1 R2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TAll y T1 U1 = TAll z S1 S2&quot;</span></span></span><span>
</span><span>           </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z &#8713; {x,y} &#8746; (fst ` set &#915; &#8746; UNION (snd ` set &#915;) FFVars) &#8746; FFVars S1 &#8746; FFVars R1&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S1 = T1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S2 = vvswap y z U1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8713; FFVars S2&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z &#8713; FFVars U1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z &#8800; x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z &#8800; y&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;U. (z, U) &#8713; set &#915;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z &#8713; FFVars S1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z &#8713; FFVars R1&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;y U. (y, U) &#8712; set &#915; &#10233; z &#8713; FFVars U&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>2</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_iff</span><span> </span><span>vusubst_def</span><span> </span><span>supp_id_upd</span><span> </span><span>swap_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vvsubst_cong</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; R1 &lt;: S1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(z, R1) # &#915; &#8866; S2 &lt;: R2&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8713; FFVars R2&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8713; FFVars R1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8713; FFVars T1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713; FFVars R1&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subtyping_wf_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SA_TAll</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>subtyping_wf_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>subtyping_wf_type</span><span class="delimiter">[</span><span>OF</span><span> </span><span>*</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_type_FFVars</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>TAll</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SA_TAll</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>*</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(y, R1) # &#915; &#8866; vvswap x y L2 &lt;: vvswap x y U1&#39;&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>IH</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>subtyping_vvswap_fresh</span><span>
</span><span>              </span><span>intro</span><span class="delimiter">:</span><span> </span><span>narrowing_from_transitivity</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>&#916;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[]&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(z, R1) # &#915; &#8866; vvswap y z (vvswap x y U1&#39;) &lt;: R2&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(y, R1) # &#915; &#8866; vvswap x y U1&#39; &lt;: vvswap z y R2&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>subtyping_vvswap_fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span>z</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vvsubst_o</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;swap z y&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(y, R1) # &#915; &#8866; vvswap x y L2 &lt;: vvswap z y R2&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>IH</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>*</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; TAll x L1 L2 &lt;: T&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>TAll_rename</span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>_</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>TAll_rename</span><span class="delimiter">[</span><span>of</span><span> </span><span>y</span><span> </span><span>_</span><span> </span><span>z</span><span class="delimiter">]</span><span> </span><span>SA_TAll</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>            </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>TAll</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>TAll</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>contra_subsetD</span><span> </span><span>subtyping.SA_TVar_Trans</span><span> </span><span>subtyping_wf_type</span><span> </span><span>wf_type_FFVars</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>TRec</span><span> </span><span>X</span><span> </span><span>&#915;</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>TRec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>&#915;</span><span> </span><span>S</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TRec X&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SA_TRec</span><span> </span><span>&#915;</span><span> </span><span>Y</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Z</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T = TRec Z&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;labels X &#8838; labels Z&quot;</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>XZ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x T. (x, T) &#8712;&#8712; Z &#10233; &#8707;S. (x, S) &#8712;&#8712; X &#8743; &#915; &#8866; S &lt;: T&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; TRec Y &lt;: T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T = TRec Z&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>T</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x, T) &#8712;&#8712; Z&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>XZ</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x, S) &#8712;&#8712; X&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; S &lt;: T&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>SA_TRec</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>S</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;S. (x, S) &#8712;&#8712; Y &#8743; &#915; &#8866; S &lt;: T&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lfin_values</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>TRec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subset_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SA_TRec</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>lab</span><span class="delimiter">]</span><span> </span><span>SA_TRec</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>SA_TRec</span><span class="delimiter">(</span><span>5</span><span class="delimiter">,</span><span>1</span><span>-</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>subtyping_TRecLE</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_iff</span><span> </span><span>Bex_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
