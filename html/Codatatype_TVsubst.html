<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Codatatype_TVsubst (Isabelle2018: August 2018)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Codatatype_TVsubst</h1>

<span class="command">theory</span> <span class="name">Codatatype_TVsubst</span><br/>
<span class="keyword">imports</span> <a href="Codatatype_VVsubst.html"><span class="name">Codatatype_VVsubst</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Codatatype_TVsubst</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Codatatype_VVsubst</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>&#951;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT &#8658; (&#39;a, &#39;b, &#39;c, &#39;d) F&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">axiomatization</span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>&#951;_set1_F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a. set1_F (&#951; a) = {a}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>&#951;_inj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; a1 a2. &#951; a1 = &#951; a2 &#10233; a1 = a2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>&#951;_compl_set1_F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; x. x &#8713; range &#951; &#10233; set1_F x = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>&#951;_natural</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; (f::&#39;a::vvar_TT &#8658; &#39;a) (g::&#39;b::vvar_TT &#8658; &#39;b) h i. |supp f| &lt;o bound(any::&#39;a) &#10233; bij g &#10233; |supp g| &lt;o bound(any::&#39;b) &#10233; map_F f g h i o &#951; = &#951; o f&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Immediately satisfied if (&#39;a,&#39;b) F has the form &#39;a + &#39;b G *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_F_&#951;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;|supp f| &lt;o bound(any::&#39;a) &#10233; bij g &#10233; |supp g| &lt;o bound(any::&#39;b) &#10233;
   map_F  (f::&#39;a::vvar_TT &#8658; &#39;a) (g::&#39;b::vvar_TT &#8658; &#39;b) i j (&#951; x) = &#951; (f x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>&#951;_natural</span><span class="delimiter">[</span><span>of</span><span> </span><span>f</span><span> </span><span>g</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fun_eq_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>supp_swap_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp (id (x := y, y := x :: &#39;a))| &lt;o bound(any :: &#39;a :: vvar_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ordLeq_ordLess_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>card_of_mono1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>supp_swap_le</span><span class="delimiter">]</span><span> </span><span>finite_ordLess_infinite2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>var_TT_infinite</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>&#951;_set2_F</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F (&#951; a :: (&#39;a :: vvar_TT, &#39;b :: vvar_TT, &#39;c, &#39;d) F) = {}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;b</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; set2_F (&#951; a :: (&#39;a :: vvar_TT, &#39;b :: vvar_TT, &#39;c, &#39;d) F)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8712; set2_F ((&#951; o id) a :: (&#39;a :: vvar_TT, &#39;b :: vvar_TT, &#39;c, &#39;d) F)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>&#951;_natural</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>id</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id(b:=c,c:=b) :: _ &#8658; _ :: vvar_TT&quot;</span></span></span><span> </span><span>id</span><span> </span><span>id</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>1</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_set2_map</span><span> </span><span>image_iff</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_swap</span><span> </span><span>supp_swap_bound</span><span> </span><span>o_apply</span><span>
</span><span>          </span><span>fun_upd_apply</span><span> </span><span>id_apply</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>supp_id_bound</span><span> </span><span>supp_swap_bound</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F (&#951; a :: (&#39;a :: vvar_TT, &#39;b :: vvar_TT, &#39;c, &#39;d) F) = (UNIV :: &#39;b set)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>F_set2_bd</span><span> </span><span>not_ordLess_ordLeq</span><span> </span><span>var_TT</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>&#951;_set3_F</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set3_F (&#951; a :: (&#39;a :: vvar_TT, &#39;b :: vvar_TT, &#39;c, &#39;d) F) = {}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;c</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; set3_F (&#951; a :: (&#39;a :: vvar_TT, &#39;b :: vvar_TT, &#39;c, &#39;d) F)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8712; set3_F ((&#951; o id) a :: (&#39;a :: vvar_TT, &#39;b :: vvar_TT, bd_type_TT set, &#39;d) F)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>&#951;_natural</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>id</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id :: _ &#8658; _ :: vvar_TT&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;_. c&quot;</span></span></span><span> </span><span>id</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_set3_map</span><span> </span><span>image_iff</span><span> </span><span>supp_id_bound</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set3_F (&#951; a :: (&#39;a :: vvar_TT, &#39;b :: vvar_TT, bd_type_TT set, &#39;d) F) = (UNIV :: bd_type_TT set set)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bd_TT &lt;o |set3_F (&#951; a :: (&#39;a :: vvar_TT, &#39;b :: vvar_TT, bd_type_TT set, &#39;d) F) :: bd_type_TT set set|&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_order_Pow</span><span> </span><span>F.bd_card_order</span><span> </span><span>card_order_on_Card_order</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>F.set_bd</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#951; a&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_ordLeq_ordLess</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>&#951;_set4_F</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set4_F (&#951; a :: (&#39;a :: vvar_TT, &#39;b :: vvar_TT, &#39;c, &#39;d) F) = {}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;d</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; set4_F (&#951; a :: (&#39;a :: vvar_TT, &#39;b :: vvar_TT, &#39;c, &#39;d) F)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8712; set4_F ((&#951; o id) a :: (&#39;a :: vvar_TT, &#39;b :: vvar_TT, &#39;c, bd_type_TT set) F)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>&#951;_natural</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>id</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id :: _ &#8658; _ :: vvar_TT&quot;</span></span></span><span> </span><span>id</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;_. c&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_set4_map</span><span> </span><span>image_iff</span><span> </span><span>supp_id_bound</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set4_F (&#951; a :: (&#39;a :: vvar_TT, &#39;b :: vvar_TT, &#39;c, bd_type_TT set) F) = (UNIV :: bd_type_TT set set)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bd_TT &lt;o |set4_F (&#951; a :: (&#39;a :: vvar_TT, &#39;b :: vvar_TT, &#39;c, bd_type_TT set) F) :: bd_type_TT set set|&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Card_order_Pow</span><span> </span><span>F.bd_card_order</span><span> </span><span>card_order_on_Card_order</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>F.set_bd</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#951; a&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_ordLeq_ordLess</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>&#951;_transfer</span><span class="delimiter">[</span><span>folded</span><span> </span><span>rel_F_id_def</span><span class="delimiter">,</span><span> </span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;rel_fun (=) (rel_F (id :: &#39;a::vvar_TT&#8658;&#39;a) (id :: &#39;a::vvar_TT&#8658;&#39;a) R S) &#951; &#951;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_fun_def</span><span> </span><span>F_rel_map_set2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>_</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F id id _ _ (&#951; x)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>F.set_map</span><span> </span><span>F.map_comp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>map_F_&#951;</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>&#951;_set3_F</span><span> </span><span>&#951;_set4_F</span><span> </span><span>supp_id</span><span> </span><span>card_of_empty4</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>VVr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT &#8658; &#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;VVr a &#8801; cctor (&#951; a)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VVr_inj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;VVr a1 = VVr a2 &#10231; a1 = a2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>VVr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>&#951;_inj</span><span> </span><span>TT_inject</span><span> </span><span>map_F_&#951;</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isVVr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT TT &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;isVVr t &#8801; (&#8707;a. t = VVr a)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>asVVr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT TT &#8658; &#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;asVVr t &#8801; if isVVr t then (SOME a. VVr a = t) else undefined&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>asVVr_VVr</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;asVVr (VVr t) = t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>asVVr_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>someI_ex</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isVVr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>VVr_inj</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isVVr_asVVr</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isVVr t&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;VVr (asVVr t) = t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>asVVr_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>someI_ex</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isVVr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>VVr_inj</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FFVars_VVr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FFVars (VVr a) = {a}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>VVr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>&#951;_set1_F</span><span> </span><span>&#951;_set3_F</span><span> </span><span>&#951;_set4_F</span><span> </span><span>FFVars_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isVVr_FFVars_asVVr</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isVVr t&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FFVars t = {asVVr t}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FFVars_VVr</span><span> </span><span>assms</span><span> </span><span>isVVr_asVVr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_TT_VVr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (g::&#39;a::vvar_TT&#8658;&#39;a) &#10233; |supp g| &lt;o bound(any::&#39;a) &#10233; map_TT g (VVr a) = VVr (g a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>VVr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>&#951;_natural</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>o_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span> </span><span>map_TT_cctor</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(***************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Substitution of terms for variables  *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(***************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The Support of a substitution function f: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SSupp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT &#8658; &#39;a TT) &#8658; &#39;a set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;SSupp f &#8801; {a . f a &#8800; VVr a}&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The Support of f factoring in the image too: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>IImsupp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT &#8658; &#39;a TT) &#8658; &#39;a set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IImsupp f &#8801; SSupp f &#8746; (&#8899; a &#8712; SSupp f. FFVars (f a))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SSupp_VVr_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp VVr| &lt;o bound(any::&#39;a::vvar_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SSupp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>emp_bound</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IImsupp_SSupp_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;|IImsupp (g::&#39;a::vvar_TT&#8658;&#39;a TT)| &lt;o bound(any::&#39;a) &#10231; |SSupp g| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ordLeq_ordLess_trans</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>card_of_mono1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IImsupp_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>IImsupp_def</span><span> </span><span>bound_cinfinite</span><span> </span><span>bound_Card_order</span><span> </span><span>card_of_FFVars_bound</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Un_bound</span><span> </span><span>UNION_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_isVVr_set1_F</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; isVVr (cctor x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set1_F x = {}&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isVVr_def</span><span> </span><span>VVr_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>&#951;_compl_set1_F</span><span> </span><span>image_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IImsupp_imsupp_map_TT_commute</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT&#8658;&#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT&#8658;&#39;a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>fg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IImsupp f &#8745; imsupp g = {}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij g&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp g| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_TT g (f a) = f (g a)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g a = a&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>g</span><span> </span><span class="delimiter">=</span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f a = VVr a&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span> </span><span>gg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_TT_VVr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_TT g (f a) = f a&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fg</span><span> </span><span>gg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>map_TT_cong_id</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>  </span><span>IImsupp_def</span><span> </span><span>SSupp_def</span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span> </span><span>alpha_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f a = VVr a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fg</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span>IImsupp_def</span><span> </span><span>SSupp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g (g a) &#8800; g a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gg</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_def</span><span> </span><span>inj_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f (g a) = VVr (g a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fg</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span> </span><span>IImsupp_def</span><span> </span><span>SSupp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>f</span><span> </span><span>gg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_TT_VVr</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TT_VVr_cases</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>VVr</span><span> </span><span>nonVVr</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>type</span><span class="delimiter">:</span><span> </span><span>TT</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = VVr a&quot;</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; isVVr t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>isVVr_asVVr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="tfree">&#39;a</span><span> </span><span class="delimiter">::</span><span> </span><span>vvar_TT</span><span> </span><span>SSfun</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{f :: &#39;a &#8658; &#39;a TT. |SSupp f| &lt;o bound(any :: &#39;a)}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>VVr</span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>SSupp_VVr_bound</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_TT_eq_VVr_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bij (f :: &#39;a &#8658; &#39;a :: vvar_TT) &#10233; |supp f| &lt;o bound(any :: &#39;a) &#10233;
    map_TT f x = VVr y &#10231; (&#8707;z. x = VVr z &#8743; y = f z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>VVr_inj</span><span> </span><span>map_TT_VVr</span><span> </span><span>map_TT_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span> </span><span>map_TT_id</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_TT f x&quot;</span></span></span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_TT (inv f)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SSupp_comp_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a :: vvar_TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound (any :: &#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SSupp (f o u) &#8838; SSupp f &#8746; supp u&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SSupp_def</span><span> </span><span>supp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_TT_VVr</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SSupp_comp_le2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a :: vvar_TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound (any :: &#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SSupp (map_TT u o f) &#8838; SSupp f &#8746; supp u&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SSupp_def</span><span> </span><span>supp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_TT_VVr</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SSupp_comp_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a :: vvar_TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp f| &lt;o bound (any :: &#39;a)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound (any :: &#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp (f o u)| &lt;o bound (any :: &#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ordLeq_ordLess_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>card_of_mono1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SSupp_comp_le</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>Un_bound</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SSupp_comp_bound2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a :: vvar_TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound (any :: &#39;a)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp f| &lt;o bound (any :: &#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp (map_TT u o f)| &lt;o bound (any :: &#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ordLeq_ordLess_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>card_of_mono1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>SSupp_comp_le2</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>Un_bound</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_SSfun</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>vvrSS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a :: vvar_TT SSfun&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>VVr</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SSupp_VVr_bound</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a :: vvar_TT &#8658; &#39;a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any :: &#39;a)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>compSS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a :: vvar_TT SSfun &#8658; &#39;a SSfun&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;p. map_TT u o p o inv u&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>supp_inv_bound</span><span> </span><span>SSupp_comp_bound</span><span> </span><span>SSupp_comp_bound2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a :: vvar_TT &#8658; &#39;a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any :: &#39;a)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compSS_inv_compSS</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;compSS (inv u) (compSS u p) = p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>bij_imp_bij_inv</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>map_TT_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_TT_id</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a :: vvar_TT &#8658; &#39;a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any :: &#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any :: &#39;a)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compSS_o</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;compSS (u o v) p = compSS u (compSS v p)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>bij_comp</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span> </span><span>supp_comp_bound</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>o_inv_distrib</span><span> </span><span>fun_eq_iff</span><span> </span><span>map_TT_comp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compSS_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;compSS id = id&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>supp_id_bound</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span> </span><span>bij_id</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>transfer</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_TT_id</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">&#39;a</span><span> </span><span>D</span><span> </span><span class="delimiter">=</span><span> </span><span>D</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a TT&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a SSfun&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>DDTOR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT D &#8658; (&#39;a, &#39;a, &#39;a TT + &#39;a D , &#39;a TT + &#39;a D) F set)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;DDTOR = (&#955;d. case d of D t f &#8658; if isVVr t then {map_F id id Inl Inl x | x. Rep_SSfun f (asVVr t) = cctor x}
      else
      {map_F id id (&#955;x. Inr (D x f)) (&#955;x. Inr (D x f)) x | x.
        t = cctor x &#8743; set2_F x &#8745; IImsupp (Rep_SSfun f) = {}})&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mmapD</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT &#8658; &#39;a) &#8658; &#39;a D &#8658; &#39;a D&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mmapD = (&#955;u d. case d of D x f &#8658; D (map_TT u x) (compSS u f))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FFVarsD</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT D &#8658; &#39;a set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;FFVarsD = (&#955;d. case d of D x f &#8658; FFVars x &#8746; IImsupp (Rep_SSfun f))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>D.splits</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>comodel_defs</span><span> </span><span class="delimiter">=</span><span> </span><span>DDTOR_def</span><span> </span><span>mmapD_def</span><span> </span><span>FFVarsD_def</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Comodel properties: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Full-corecursion version of the clauses (Dne), (MD), (VD) and (DRen) from the paper: *)</span></span></span></span></span><span>
</span><span>  </span><span>DDTOR_ne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;DDTOR d &#8800; {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>  </span><span>DDTOR_mmapD0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{X,X&#39;} &#8838; DDTOR d &#10233; 
&#8707;u. bij (u::&#39;a &#8658; &#39;a) &#8743; |supp u| &lt;o bound(any::&#39;a::vvar_TT) &#8743; id_on (UNION (set4_F X) (case_sum FFVars FFVarsD) - set2_F X) u &#8743; 
     map_F id u id (map_sum (map_TT u) (mmapD u)) X = X&#39;&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>   
</span><span>  </span><span>FFVarsD_DDTOR0</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; DDTOR d &#10233; 
  set1_F X &#8746; UNION (set3_F X) (case_sum FFVars FFVarsD) &#8746;
   (UNION (set4_F X) (case_sum FFVars FFVarsD) - set2_F X) &#8838; 
  FFVarsD d&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>  
</span><span>  </span><span>mmapD_DDTOR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a) &#10233; |supp u| &lt;o bound(any::&#39;a::vvar_TT) &#10233; 
  DDTOR (mmapD u d) &#8838;
  image 
    (map_F u u (map_sum (map_TT u) (mmapD u)) (map_sum (map_TT u) (mmapD u))) 
    (DDTOR d)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Comodels are a restricted term-like structure: *)</span></span></span></span></span><span>
</span><span>  </span><span>termLikeStr_mmapD_FFVarsD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;termLikeStrD mmapD&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comodel_defs</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>TT_nchotomy</span><span> </span><span>fresh_nchotomy</span><span> </span><span>IImsupp_SSupp_bound</span><span> </span><span>Rep_SSfun</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>TT_inject0</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span> </span><span>F_set_map</span><span> </span><span>FFVars_map_TT</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>u</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv u&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_inv_bound</span><span> </span><span>id_on_def</span><span> </span><span>image_iff</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span>
</span><span>            </span><span>map_sum_def</span><span> </span><span>map_TT_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>o_def</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_TT_id</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>TT_fresh_inject</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IImsupp (Rep_SSfun p)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IImsupp_SSupp_bound</span><span> </span><span>Rep_SSfun</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>u</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_inv_bound</span><span> </span><span>supp_id_bound</span><span> </span><span>supp_comp_bound</span><span> </span><span>Rep_SSfun</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>            </span><span>F_set_map</span><span> </span><span>FFVars_map_TT</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>id_on_def</span><span>
</span><span>            </span><span>map_TT_id</span><span> </span><span>map_TT_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>bij_imp_inv</span><span>
</span><span>            </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>F_map_cong</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>imsupp_def</span><span> </span><span>supp_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>prems</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">,</span><span>8</span><span class="delimiter">)</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span> </span><span>bij_imp_bij_inv</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">,</span><span>9</span><span class="delimiter">,</span><span>10</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">,</span><span>8</span><span class="delimiter">)</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>p</span><span> </span><span>a</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IImsupp_imsupp_map_TT_commute</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>u</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv u a&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">,</span><span>8</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span> </span><span>Rep_SSfun</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span>FFVars_simps</span><span> </span><span>isVVr_def</span><span> </span><span>FFVars_VVr</span><span>
</span><span>        </span><span>asVVr_VVr</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IImsupp_def</span><span> </span><span>SSupp_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FFVars_VVr</span><span> </span><span>FFVars_intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>singleton_iff</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FFVars_VVr</span><span> </span><span>FFVars_intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>singleton_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FFVars_VVr</span><span> </span><span>FFVars_intros</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>insertI1</span><span> </span><span>insert_Diff_if</span><span> </span><span>insert_absorb</span><span> </span><span>singleton_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>if_splits</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_TT (inv u)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isVVr_def</span><span> </span><span>map_TT_VVr</span><span> </span><span>VVr_inj</span><span>
</span><span>          </span><span>image_iff</span><span> </span><span>asVVr_VVr</span><span> </span><span>compSS.rep_eq</span><span> </span><span>map_TT_cctor</span><span>
</span><span>          </span><span>map_TT_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span> </span><span>map_TT_id</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span>conjI</span><span> </span><span>refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span> </span><span>Rep_ssfun</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>          </span><span>image_iff</span><span> </span><span>map_sum_def</span><span> </span><span>compSS.rep_eq</span><span> </span><span>supp_comp_bound</span><span> </span><span>supp_inv_bound</span><span> </span><span>F_set_map</span><span>
</span><span>          </span><span>inv_o_simp1</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rewriteR_comp_comp</span><span class="delimiter">]</span><span> </span><span>map_TT_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_TT_id</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>sum.splits</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>F_map_cong</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isVVr_def</span><span> </span><span>map_TT_VVr</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isVVr_def</span><span> </span><span>map_TT_eq_VVr_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span> </span><span>p</span><span> </span><span>_</span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_TT (inv u)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_iff</span><span> </span><span>map_TT_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span> </span><span>map_TT_id</span><span> </span><span>map_TT_cctor</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span>conjI</span><span> </span><span>refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span> </span><span>Rep_ssfun</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>          </span><span>image_iff</span><span> </span><span>map_sum_def</span><span> </span><span>compSS.rep_eq</span><span> </span><span>supp_comp_bound</span><span> </span><span>supp_inv_bound</span><span> </span><span>F_set_map</span><span>
</span><span>          </span><span>inv_o_simp1</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>rewriteR_comp_comp</span><span class="delimiter">]</span><span> </span><span>map_TT_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_TT_id</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>sum.splits</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>F_map_cong</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>disjoint_iff_not_equal</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>bspec</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IImsupp_def</span><span> </span><span>SSupp_def</span><span> </span><span>ball_Un</span><span> </span><span>FFVars_map_TT</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_inv_bound</span><span> </span><span>map_TT_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_TT_id</span><span> </span><span>map_TT_VVr</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;VVr x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_TT (inv u)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>_</span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u x&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>supp_inv_bound</span><span> </span><span>map_TT_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_TT_id</span><span> </span><span>map_TT_VVr</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;VVr (u x)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_TT (inv u)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_TT_id</span><span> </span><span>map_TT_comp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Defined analogously to the FVarsB: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FFVarsBD</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT, &#39;a, &#39;a TT + &#39;a D, &#39;a TT + &#39;a D) F &#8658; &#39;a set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;FFVarsBD X &#8801; UNION (set4_F X) (case_sum FFVars FFVarsD) - set2_F X&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>DDTOR_mmapD</span><span> </span><span class="delimiter">=</span><span> </span><span>DDTOR_mmapD0</span><span class="delimiter">[</span><span>folded</span><span> </span><span>FFVarsBD_def</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>FFVarsD_DDTOR</span><span> </span><span class="delimiter">=</span><span> </span><span>FFVarsD_DDTOR0</span><span class="delimiter">[</span><span>folded</span><span> </span><span>FFVarsBD_def</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapD_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapD id d = d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>termLikeStr_mmapD_FFVarsD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapD_comp</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a) &#10233; |supp u| &lt;o bound (any::&#39;a::vvar_TT) &#10233; bij v &#10233; |supp v| &lt;o bound (any::&#39;a) &#10233; 
 mmapD (u o v) d = mmapD u (mmapD v d)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>termLikeStr_mmapD_FFVarsD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mmapD_DDTOR_strong</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a::vvar_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;DDTOR (mmapD u d) =
 image 
   (map_F u u (map_sum (map_TT u) (mmapD u)) (map_sum (map_TT u) (mmapD u))) 
   (DDTOR d)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?L = ?R&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?L &#8838; ?R&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mmapD_DDTOR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>iu</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (inv u)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp (inv u)| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>dd</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dd &#8801; mmapD u d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;d = mmapD (inv u) dd&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dd_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mmapD_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mmapD u &#8728; (mmapD (inv u)) = id&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fun_eq_iff</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>iu</span><span> </span><span>mmapD_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?R &#8838; ?L&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dd_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>d</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mmapD_DDTOR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>iu</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>dd</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>iu</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>map_sum.comp</span><span> </span><span>TT_map_o</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_TT_id</span><span> </span><span>mmapD_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_sum.id</span><span> </span><span>F_map_id</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The raw-term-based model infrastructure *)</span></span></span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>DTOR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT D &#8658; (&#39;a, &#39;a, &#39;a T + &#39;a D, &#39;a T + &#39;a D) F set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;DTOR d &#8801;  map_F id id (map_sum rep_TT id) (map_sum rep_TT id) ` (DDTOR d)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>mapD</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT &#8658; &#39;a) &#8658; &#39;a D &#8658; &#39;a D&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mapD &#8801; mmapD&quot;</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>FVarsD</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT D &#8658; &#39;a set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsD &#8801; FFVarsD&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FVarsBD</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT, &#39;a, &#39;a T + &#39;a D, &#39;a T + &#39;a D) F &#8658; &#39;a set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsBD X &#8801; UNION (set4_F X) (case_sum FVars FVarsD) - set2_F X&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>FVars_def2</span><span> </span><span class="delimiter">=</span><span> </span><span>FFVars.abs_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Raw-term-based version of the assumptions: *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mapD_id</span><span> </span><span class="delimiter">=</span><span> </span><span>mmapD_id</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mapD_comp</span><span> </span><span class="delimiter">=</span><span> </span><span>mmapD_comp</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FVarsBD_FFVarsBD</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsBD X = FFVarsBD (map_F id id (map_sum abs_TT id) (map_sum abs_TT id) X)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVarsBD_def</span><span> </span><span>FFVarsBD_def</span><span> </span><span>FVars_def2</span><span>   
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>FVars_def2</span><span> </span><span>case_sum_map_sum</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>o_def</span><span> </span><span>id_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DTOR_mapD</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{X,X&#39;} &#8838; DTOR d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;u. bij (u::&#39;a&#8658;&#39;a) &#8743; |supp u| &lt;o bound(any::&#39;a::vvar_TT) &#8743; id_on (FVarsBD X) u &#8743; 
     rel_F id u 
       (rel_sum alpha (=)) 
       (rel_sum (&#955; t t&#39;. alpha (map_T u t) t&#39;) (&#955; d d&#39;. mapD u d = d&#39;)) 
     X X&#39;&quot;</span></span></span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>XX</span><span> </span><span>XX&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;XX &#8801; map_F id id (map_sum abs_TT id) (map_sum abs_TT id) X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;XX&#39; &#8801; map_F id id (map_sum abs_TT id) (map_sum abs_TT id) X&#39;&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{XX,XX&#39;} &#8838; DDTOR d&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XX_def</span><span> </span><span>XX&#39;_def</span><span> </span><span>DTOR_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_sum.comp</span><span> </span><span>abs_rep_TT</span><span> </span><span>map_sum.id</span><span> </span><span>F_map_id</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>       
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id_on (FFVarsBD XX) u&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F id u id (map_sum (map_TT u) (mmapD u)) XX = XX&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DDTOR_mmapD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;asSS (asBij u) = u&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;asSS u = u&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>asSS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>u</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>safe</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id_on (FVarsBD X) u&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id_on_def</span><span> </span><span>XX_def</span><span> </span><span>FVarsBD_FFVarsBD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F id u (rel_sum alpha (=)) (rel_sum (&#955;t. alpha (map_T u t)) (&#955;d d&#39;. mapD u d = d&#39;)) X X&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XX_def</span><span> </span><span>XX&#39;_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>F_map_id</span><span> </span><span>map_sum.comp</span><span> </span><span>map_TT_def</span><span> </span><span>F.rel_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>F_rel_map</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F_rel_mono_strong1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Grp_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>d1</span><span> </span><span>d2</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TT.abs_eq_iff</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>d1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d2</span><span class="delimiter">,</span><span>fastforce</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>d1</span><span> </span><span>d2</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TT.abs_eq_iff</span><span> </span><span>abs_TT_alpha_aux</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>d1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>d2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>d2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>insert</span><span> </span><span>u</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DTOR_ne</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;DTOR d &#8800; {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DTOR_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DDTOR_ne</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FVarsD_DTOR</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; DTOR d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set1_F X &#8746; UNION (set3_F X) (case_sum FVars FVarsD) &#8746; FVarsBD X &#8838; FVarsD d&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>XX</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;XX &#8801; map_F id id (map_sum abs_TT id) (map_sum abs_TT id) X&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;XX &#8712; DDTOR d&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XX_def</span><span> </span><span>DTOR_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_sum.comp</span><span> </span><span>abs_rep_TT</span><span> </span><span>map_sum.id</span><span> </span><span>F_map_id</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FFVarsD_DDTOR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVarsBD_FFVarsBD</span><span> </span><span>XX_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>FVars_def2</span><span> </span><span>case_sum_map_sum</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVars_def2</span><span> </span><span>o_def</span><span> 
</span><span>      </span><span>map_sum.simps</span><span> </span><span>id_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_set_reflI</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a. a &#8712; A &#10233; r a a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_set r A A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_set_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapD_DTOR</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a::vvar_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;rel_set
  (rel_F u u 
     (rel_sum (&#955; t t&#39;. alpha (map_T u t) t&#39;) (&#955; d d&#39;. mapD u d = d&#39;))
     (rel_sum (&#955; t t&#39;. alpha (map_T u t) t&#39;) (&#955; d d&#39;. mapD u d = d&#39;)))
 (DTOR d)
 (DTOR (mapD u d))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DTOR_def</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_set_reflI</span><span> </span><span>F.rel_refl_strong</span><span> </span><span>sum.rel_refl_strong</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mmapD_DDTOR_strong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>d</span><span class="delimiter">]</span><span> </span><span>rel_set_image</span><span> </span><span>u</span><span> </span><span>F_rel_map</span><span> </span><span>OO_def</span><span> </span><span>Grp_def</span><span> </span><span>sum.rel_map</span><span> 
</span><span>      </span><span>map_TT_def</span><span> </span><span>asSS_def</span><span> </span><span>alpha_rep_abs_TT</span><span> </span><span>alpha_sym</span><span>
</span><span>      </span><span>image_comp</span><span> </span><span>F_map_comp1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_sum.comp</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>  
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*    *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>suitable</span><span> </span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT D &#8658; (&#39;a,&#39;a,&#39;a T + &#39;a D,&#39;a T + &#39;a D)F) &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick &#8801; &#8704; d. pick d &#8712; DTOR d&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT D &#8658; (&#39;a,&#39;a,&#39;a T + &#39;a D,&#39;a T + &#39;a D)F) &#8658; &#39;a D =&gt; &#39;a T&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;f pick &#8801; corec_T pick&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>T.corec</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick o DTOR&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>f_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_simps</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;f pick d = ctor (map_F id id (case_sum id (f pick)) (case_sum id (f pick)) (pick d))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>T.corec</span><span class="delimiter">[</span><span>of</span><span> </span><span>pick</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>f_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_ctor</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;ctor x = f pick d &#10233; 
 x = map_F id id (case_sum id (f pick)) (case_sum id (f pick)) (pick d)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_simps</span><span class="delimiter">[</span><span>of</span><span> </span><span>pick</span><span> </span><span>d</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suitable_FVarsD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set1_F (pick d) &#8746; UNION (set3_F (pick d)) (case_sum FVars FVarsD) &#8746; FVarsBD (pick d)
       &#8838; FVarsD d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FVarsD_DTOR</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick d&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>suitable_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_FVarsD</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVars (f pick d) &#8838; FVarsD d&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>aa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVars (f pick d)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = f pick d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FVarsD d&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>aa</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>t_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>set1</span><span> </span><span>a</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>f_ctor</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`ctor x = f pick d`</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>fvd</span><span> </span><span class="delimiter">=</span><span> </span><span>suitable_FVarsD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>d</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set1.hyps</span><span> </span><span>fvd</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>set2_free</span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>f_ctor</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`ctor x = f pick d`</span></span></span><span class="delimiter">]</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>fvd</span><span> </span><span class="delimiter">=</span><span> </span><span>suitable_FVarsD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>d</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`t &#8712; set3_F x`</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>td</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = case_sum id (f pick) td&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>td</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;td &#8712; set3_F (pick d)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; case_sum FVars FVarsD td&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set2_free.IH</span><span> </span><span>set2_free.hyps</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>td</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>td</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>rev_subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>fvd</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>set2_rec</span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span>a</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>f_ctor</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`ctor x = f pick d`</span></span></span><span class="delimiter">]</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>fvd</span><span> </span><span class="delimiter">=</span><span> </span><span>suitable_FVarsD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>d</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`t &#8712; set4_F x`</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>td</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = case_sum id (f pick) td&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>td</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;td &#8712; set4_F (pick d)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; case_sum FVars FVarsD td&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set2_rec.IH</span><span> </span><span>set2_rec.hyps</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>td</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8713; set2_F (pick d)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`a &#8713; set2_F x`</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>td</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>rev_subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>fvd</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FVarsBD_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_F_suitable_mapD</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>pp&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a::vvar_TT)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707; v. bij v &#8743; |supp v| &lt;o bound(any::&#39;a) &#8743; id_on (FVarsBD (pick d)) v &#8743; 
 rel_F u (u o v)   
   (rel_sum (&#955;t t&#39;. alpha (map_T u t) t&#39;) 
            (&#955;d d&#39;. d&#39; = mapD u d))
   (rel_sum (&#955;t t&#39;. alpha (map_T (u o v) t) t&#39;) 
            (&#955;d d&#39;. mapD (u o v) d = d&#39;))
 (pick d)  
 (pick&#39; (mapD u d))&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick d &#8712; DTOR d&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick&#39; (mapD u d) &#8712; DTOR (mapD u d)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pp&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>X</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; DTOR d&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F u u 
       (rel_sum (&#955;t. alpha (map_T u t)) (&#955;d. (=) (mapD u d)))
       (rel_sum (&#955;t. alpha (map_T u t)) (&#955;d. (=) (mapD u d)))
     X (pick&#39; (mapD u d))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mapD_DTOR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>d</span><span class="delimiter">]</span><span> </span><span>p&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rel_set_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id_on (FVarsBD (pick d)) v&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F id v 
      (rel_sum alpha (=)) 
      (rel_sum (&#955;t. alpha (map_T v t)) (&#955;d. (=) (mapD v d))) 
   (pick d) X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DTOR_mapD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick d&quot;</span></span></span><span> </span><span>X</span><span> </span><span>d</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pp&#39;</span><span> </span><span>X</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>v</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F_rel_mono_strong1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>F_rel_comp_imp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>2</span><span> </span><span>0</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>supp_comp_bound</span><span> </span><span>supp_inv_bound</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>td1</span><span> </span><span>td3</span><span> </span><span>td2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_refl</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>td1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> 
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>td2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>td3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>alpha_bij_eq</span><span> </span><span>alpha_trans</span><span> </span><span>rel_sum_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>u</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>td2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>td3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>td1</span><span> </span><span>td3</span><span> </span><span>td2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_refl</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>td1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> 
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>td2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>td3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span>  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>T_map_comp</span><span> </span><span>supp_inv_bound</span><span> 
</span><span>          </span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_bij_eq</span><span> </span><span>alpha_trans</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>u</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>td2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>td3</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>T_map_comp</span><span> </span><span>mapD_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The &quot;monster lemma&quot;: termLikeStr and &quot;pick&quot;-irrelevance covered in one shot: *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_swap_alpha</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a::vvar_TT)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T u (f pick d)) (f pick&#39; (mapD u d))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?&#966;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955; tL tR. &#8707; u d. bij u &#8743; |supp u| &lt;o bound(any::&#39;a) &#8743; 
   tL = map_T u (f pick d) &#8743; tR = f pick&#39; (mapD u d)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>tL</span><span> </span><span>tR</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?&#966; tL tR&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha tL tR&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>alpha_coinduct2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>C</span><span> </span><span>xL</span><span> </span><span>xR</span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span>d</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>  
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ctor xL = map_T u (f pick d)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ctor xR = f pick&#39; (mapD u d)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>xL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xL = map_F u u (map_T u &#8728; case_sum id (f pick)) (map_T u&#8728; case_sum id (f pick)) (pick d)&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xR = map_F id id (case_sum id (f pick&#39;)) (case_sum id (f pick&#39;)) (pick&#39; (mapD u d))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_simps</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>f_simps</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick&#39;&quot;</span></span></span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>map_T_simps</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij v&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp v| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>iv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id_on (FVarsBD (pick d)) v&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rv</span><span class="delimiter">:</span><span>   
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F u (u &#8728; v) 
       (rel_sum (&#955;t. alpha (map_T u t)) (&#955;d d&#39;. d&#39; = mapD u d))
       (rel_sum (&#955;t. alpha (map_T (u &#8728; v) t)) (&#955;d. (=) (mapD (u &#8728; v) d))) 
     (pick d) (pick&#39; (mapD u d)) &quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rel_F_suitable_mapD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>p</span><span> </span><span>p&#39;</span><span> </span><span>u</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>w</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w &#8801; u o v o inv u&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>w</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij w&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp w| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>w_def</span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>supp_comp_bound</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fv_xL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsB xL &#8838; u ` (FVarsBD (pick d))&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_FVarsD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>p</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>xL</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>F_set_map</span><span> </span><span>FVars_map_T</span><span> </span><span>FVarsBD_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>td</span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>td</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span> </span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fv_p&#39;d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsBD (pick d) &#8838; FVarsD d&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FVarsD_DTOR</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick d&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id_on (u ` (FVarsBD (pick d))) w&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iv</span><span> </span><span>fv_p&#39;d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id_on_def</span><span> </span><span>xL</span><span> </span><span>w_def</span><span> </span><span>eq_on_def</span><span> </span><span>id_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>u</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>iw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id_on (FVarsB xL) w&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fv_xL</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>id_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>w</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_F id w
      (&#955;t t&#39;. (&#8707;u d. bij u &#8743; |supp u| &lt;o bound(any::&#39;a) &#8743;   
                     t = map_T u (f pick d) &#8743; t&#39; = f pick&#39; (mapD u d))
              &#8744; alpha t t&#39;)
      (&#955;t t&#39;. (&#8707;u d. bij u &#8743; |supp u| &lt;o bound(any::&#39;a) &#8743; 
                     map_T w t = map_T u (f pick d)  &#8743; t&#39; = f pick&#39; (mapD u d))
              &#8744; alpha (map_T w t) t&#39;)
      xL xR&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>xL</span><span> </span><span>xR</span><span>  
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>w</span><span> </span><span>u</span><span> </span><span>F_rel_map</span><span> </span><span>Grp_def</span><span> </span><span>OO_def</span><span> </span><span>supp_comp_bound</span><span> </span><span>supp_inv_bound</span><span> </span><span>T_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F_rel_mono_strong0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>rv</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>  
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; set2_F (pick d)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u (v a) = w (u a)&quot;</span></span></span><span>  
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>w_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ttdL</span><span> </span><span>ttdR</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ttdLin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ttdL &#8712; set3_F (pick d)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ttdRin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ttdR &#8712; set3_F (pick&#39; (mapD u d))&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_sum (&#955;t. alpha (map_T u t)) (&#955;d d&#39;. d&#39; = mapD u d) ttdL ttdR&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>na</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; alpha (map_T u (case_sum id (f pick) ttdL)) (case_sum id (f pick&#39;) ttdR)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>tL</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>000</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ttdL = Inl tL&quot;</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>tR</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ttdR = Inl tR&quot;</span></span></span><span>
</span><span>              </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T u tL) tR&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; alpha (map_T u tL) tR&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span> </span><span>na</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ttdR</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T u tL) (map_T u tL)&quot;</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>alpha_cong</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span class="delimiter">)</span><span>  
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_trans</span><span> </span><span>alpha_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>dd</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ttdL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ttdL = Inr dd&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ttdL</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ttdR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ttdR = Inr (mapD u dd)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>ttdR</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fv_dd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FVarsD dd &#8838; FVarsD d&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ttdLin</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ttdL</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FVarsD_DTOR</span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>        
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;uu. bij uu &#8743; |supp uu| &lt;o bound(any::&#39;a) &#8743;
             (&#8707; dd. map_T u (case_sum id (f pick) ttdL) = map_T uu (f pick dd) &#8743;
                    case_sum id (f pick&#39;) ttdR = f pick&#39; (mapD uu dd))&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>ttdL</span><span> </span><span>ttdR</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>u</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>dd</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ttdL</span><span> </span><span>ttdR</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ttdLin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ttdL &#8712; set4_F (pick d)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ttdRin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ttdR &#8712; set4_F (pick&#39; (mapD u d))&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel_sum (&#955;t. alpha (map_T (u &#8728; v) t)) (&#955;d. (=) (mapD (u &#8728; v) d)) ttdL ttdR&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>na</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; alpha (map_T (w &#8728; u) (case_sum id (f pick) ttdL)) (case_sum id (f pick&#39;) ttdR)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uvw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u &#8728; v = w &#8728; u&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>w_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>tL</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>000</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ttdL = Inl tL&quot;</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>tR</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ttdR = Inl tR&quot;</span></span></span><span>
</span><span>              </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T (u &#8728; v) tL) tR&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; alpha (map_T (w &#8728; u) tL) tR&quot;</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span> </span><span>na</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ttdR</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T (u &#8728; v) tL) (map_T (w &#8728; u) tL)&quot;</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uvw</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_refl</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>   
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_trans</span><span> </span><span>alpha_sym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>dd</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ttdL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ttdL = Inr dd&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ttdL</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ttdR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ttdR = Inr (mapD (u &#8728; v) dd)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ttdR</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>        
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;uu. bij uu &#8743; |supp uu| &lt;o bound(any::&#39;a) &#8743;
              (&#8707; dd. map_T (w &#8728; u) (case_sum id (f pick) ttdL) = map_T uu (f pick dd) &#8743;
                     case_sum id (f pick&#39;) ttdR = f pick&#39; (mapD uu dd))&quot;</span></span></span><span>  
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u</span><span> </span><span>w</span><span> </span><span>supp_comp_bound</span><span> </span><span>ttdL</span><span> </span><span>ttdR</span><span> </span><span>uvw</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w o u&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>dd</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>w</span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span>supp_comp_bound</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>w</span><span> </span><span>iw</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f_alpha</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick&#39;&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (f pick d) (f pick&#39; d)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_swap_alpha</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>d</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>T_map_id</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*******************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Committing to a particular pick function: *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pick0</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT D &#8658; (&#39;a, &#39;a, &#39;a T + &#39;a D, &#39;a T + &#39;a D) F&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;pick0 &#8801; SOME pick. suitable pick&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exists_suitable</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707; pick. suitable pick&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;d. &#8707; X. X &#8712; DTOR d&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DTOR_ne</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>suitable_pick0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>someI_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>exists_suitable</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pick0_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>f0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f0 &#8801; f pick0&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>f0_low_level_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>f_simps</span><span class="delimiter">[</span><span>of</span><span> </span><span>pick0</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>f0_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f0_DTOR</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; DTOR d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (f0 d) (ctor (map_F id id (case_sum id f0) (case_sum id f0) X))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>pick1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick1 &#8801; &#955; d&#39;. if d&#39; = d then X else pick0 d&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;suitable pick1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suitable_pick0</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>suitable_def</span><span> </span><span>pick1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pick1 d = X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pick1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; dd. alpha (f0 dd) (f pick1 dd)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_alpha</span><span class="delimiter">[</span><span>OF</span><span> </span><span>suitable_pick0</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f0_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f pick1 d = ctor (map_F id id (case_sum id (f pick1)) (case_sum id (f pick1)) X)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>f_simps</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (ctor (map_F id id (case_sum id (f pick1)) (case_sum id (f pick1)) X)) 
                       (ctor (map_F id id (case_sum id f0) (case_sum id f0) X))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>alpha.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span>id</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_rel_map</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Grp_def</span><span> </span><span>OO_def</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F.rel_refl_strong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>td</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>td</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>alpha_refl</span><span> </span><span>alpha_sym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>td</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>td</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>T_map_id</span><span> </span><span>alpha_refl</span><span> </span><span>alpha_sym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>3</span><span class="delimiter">[</span><span>of</span><span> </span><span>d</span><span class="delimiter">]</span><span> </span><span>5</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>4</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>f0_mapD</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a::vvar_TT)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (f0 (mapD u d)) (map_T u (f0 d))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_sym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f_swap_alpha</span><span class="delimiter">[</span><span>OF</span><span> </span><span>suitable_pick0</span><span> </span><span>suitable_pick0</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>f0_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>f0_FVarsD</span><span> </span><span class="delimiter">=</span><span> </span><span>f_FVarsD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>suitable_pick0</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>f0_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The following theorems for raw terms will now be lifted to quotiented terms: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>f0_DTOR</span><span> </span><span>f0_mapD</span><span> </span><span>f0_FVarsD</span><span> 
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*******************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* End product: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ff0</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT D &#8658; &#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ff0 d = abs_TT (f0 d)&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ff0_DDTOR</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; DDTOR d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ff0 d = cctor (map_F id id (case_sum id ff0) (case_sum id ff0) X)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DTOR_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>XX</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;XX &#8801; map_F id id (map_sum rep_TT id) (map_sum rep_TT id) X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>XX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;XX &#8712; DTOR d&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>XX_def</span><span> </span><span>DTOR_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha 
    (ctor (map_F id id (case_sum rep_TT f0) (case_sum rep_TT f0) X))
    (ctor (map_F id id (case_sum rep_TT (rep_TT &#8728; (abs_TT &#8728; f0))) 
                       (case_sum rep_TT (rep_TT &#8728; (abs_TT &#8728; f0))) X))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>alpha.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span>id</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_rel_map</span><span> </span><span>Grp_def</span><span> </span><span>OO_def</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>F.rel_refl_strong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>td</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>td</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha_refl</span><span> </span><span>alpha_rep_abs_TT</span><span> </span><span>alpha_sym</span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>td</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>td</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha_refl</span><span> </span><span>alpha_rep_abs_TT</span><span> </span><span>alpha_sym</span><span> </span><span>T_map_id</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f0_DTOR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>XX</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff0_def</span><span> </span><span>cctor_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>XX_def</span><span>  
</span><span>        </span><span>TT.abs_eq_iff</span><span> </span><span>o_case_sum</span><span> </span><span>case_sum_o_map_sum</span><span class="delimiter">)</span><span>   
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>o_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ff0_mmapD</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (u::&#39;a&#8658;&#39;a)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound(any::&#39;a::vvar_TT)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ff0 (mmapD u d) = map_TT u (ff0 d)&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (f0 (mmapD u d)) (map_T u (f0 d))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (map_T u (f0 d)) (map_T u (rep_TT (abs_TT (f0 d))))&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>alpha_bij_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alpha_rep_abs_TT</span><span> </span><span>alpha_sym</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alpha (f0 (mmapD u d)) (map_T u (rep_TT (abs_TT (f0 d))))&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alpha_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f0_mapD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>d</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff0_def</span><span> </span><span>map_TT_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>TT.abs_eq_iff</span><span> </span><span>asSS_def</span><span> </span><span>asBij_def</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ff0_FFVarsD</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;FFVars (ff0 d) &#8838; FFVarsD d&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f0_FVarsD</span><span class="delimiter">[</span><span>of</span><span> </span><span>d</span><span class="delimiter">]</span><span> </span><span>alpha_FVars</span><span> </span><span>alpha_rep_abs_TT</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ff0_def</span><span> </span><span>FFVars_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span>f</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a :: vvar_TT &#8658; &#39;a TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp f| &lt;o bound (any :: &#39;a)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>fSS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a SSfun&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tvsubst</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tvsubst x = ff0 (D x fSS)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tvsubst_VVr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tvsubst (VVr x) = f x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tvsubst_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>ff0_DDTOR</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>comodel_defs</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_F id id Inl Inl (SOME F. f x = cctor F)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>isVVr_def</span><span> </span><span>asVVr_VVr</span><span> </span><span>VVr_inj</span><span> </span><span>fSS.rep_eq</span><span>
</span><span>     </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_id_bound</span><span> </span><span>case_sum_o_inj</span><span> </span><span>F.map_id</span><span>
</span><span>     </span><span>someI_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>TT_nchotomy</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f x&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tvsubst_cctor_not_isVVr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F x &#8745; (IImsupp f) = {} &#10233;
  &#172; isVVr (cctor x) &#10233; tvsubst (cctor x) = cctor (map_F id id tvsubst tvsubst x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tvsubst_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>ff0_DDTOR</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>comodel_defs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>f</span><span> </span><span>supp_id_bound</span><span> </span><span>o_def</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>fSS.rep_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FFVars_vvsubst_weak</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FFVars (tvsubst t) &#8838; FFVars t &#8746; IImsupp f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tvsubst_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ff0_FFVarsD</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>comodel_defs</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>f</span><span> </span><span>supp_id_bound</span><span> </span><span>o_def</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Rep_SSfun</span><span> </span><span>fSS.rep_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>vvsubst_cctor</span><span> </span><span>FFVars_vvsubst_weak</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IImsupp_empty_IntD1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8745; IImsupp f = {} &#10233; x &#8712; A &#10233; f x = VVr x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IImsupp_def</span><span> </span><span>SSupp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IImsupp_empty_IntD2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8745; IImsupp f = {} &#10233; x &#8712; A &#10233; x &#8712; FFVars (f a) &#10233; f a = VVr a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IImsupp_def</span><span> </span><span>SSupp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_TT_tvsubst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a :: vvar_TT &#8658; &#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp f| &lt;o bound (any :: &#39;a)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij u&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp u| &lt;o bound (any :: &#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_TT u (tvsubst f t) = tvsubst (map_TT u o f o inv u) (map_TT u t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tvsubst_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span>ff0_mmapD</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>comodel_defs</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>u</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tvsubst_def</span><span> </span><span>assms</span><span> </span><span>ff0_mmapD</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>comodel_defs</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>SSupp_comp_bound</span><span> </span><span>SSupp_comp_bound2</span><span>
</span><span>      </span><span>supp_inv_bound</span><span> </span><span>fSS_def</span><span> </span><span>compSS_def</span><span> </span><span>Abs_SSfun_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FFVars_tvsubst_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FFVars u &#10233; &#8704;x (f :: &#39;a::vvar_TT &#8658; &#39;a TT).
   u = tvsubst f (cctor x) &#10230; |SSupp f| &lt;o bound(any::&#39;a) &#10230; set2_F x &#8745; IImsupp f = {} &#10230;
   a &#8712; (&#8899;a &#8712; FFVars (cctor x). FFVars (f a))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>a</span><span> </span><span>u</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>FFVars_induct</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>consumes</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>fx</span><span> </span><span>x</span><span> </span><span>f</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isVVr (cctor x)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>isVVr_def</span><span> </span><span>tvsubst_VVr</span><span> </span><span>FFVars_VVr</span><span> </span><span>UN_iff</span><span> </span><span>bex_simps</span><span>
</span><span>       </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>FFVars_intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>tvsubst_cctor_not_isVVr</span><span> </span><span>simp_thms</span><span> </span><span>UN_iff</span><span>
</span><span>        </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span> </span><span>imsupp_supp_bound</span><span> </span><span>TT_inject0</span><span> </span><span>image_id</span><span> </span><span>id_apply</span><span> </span><span>not_isVVr_set1_F</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>set1_F</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>fx</span><span> </span><span>u</span><span> </span><span>a</span><span> </span><span>x</span><span> </span><span>f</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isVVr (cctor x)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>isVVr_def</span><span> </span><span>tvsubst_VVr</span><span> </span><span>FFVars_VVr</span><span> </span><span>UN_iff</span><span> </span><span>bex_simps</span><span>
</span><span>       </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>FFVars_intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>TT_inject0</span><span> </span><span>tvsubst_cctor_not_isVVr</span><span> </span><span>simp_thms</span><span>
</span><span>        </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>image_id</span><span> </span><span>id_apply</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>set3_F</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>v</span><span> </span><span>y</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fresh_cases</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IImsupp f&quot;</span></span></span><span> </span><span>y</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>IImsupp_SSupp_bound</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec2</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>hypsubst</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>imageI</span><span> </span><span>FFVars_intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>fx</span><span> </span><span>u</span><span> </span><span>a</span><span> </span><span>x</span><span> </span><span>f</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isVVr (cctor x)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>isVVr_def</span><span> </span><span>tvsubst_VVr</span><span> </span><span>FFVars_VVr</span><span> </span><span>UN_iff</span><span> </span><span>bex_simps</span><span>
</span><span>       </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>FFVars_intros</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>TT_inject0</span><span> </span><span>tvsubst_cctor_not_isVVr</span><span> </span><span>simp_thms</span><span>
</span><span>        </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>image_id</span><span> </span><span>id_apply</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>set2_F</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>set4_F</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>TT_inject0</span><span> </span><span>vvsubst_cctor</span><span>
</span><span>        </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>image_id</span><span> </span><span>id_apply</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>v</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;image (map_TT (inv v))&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_image</span><span> </span><span>map_TT_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_TT_id</span><span> </span><span>supp_inv_bound</span><span>
</span><span>          </span><span>map_TT_tvsubst</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>u</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fresh_cases</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IImsupp f&quot;</span></span></span><span> </span><span>u</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>IImsupp_SSupp_bound</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>hypsubst</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_TT_cctor</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec2</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>SSupp_comp_bound</span><span> </span><span>SSupp_comp_bound2</span><span> </span><span>supp_inv_bound</span><span> </span><span>bij_imp_bij_inv</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>mp</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IImsupp_def</span><span> </span><span>SSupp_def</span><span> </span><span>map_TT_eq_VVr_iff</span><span> </span><span>supp_inv_bound</span><span> </span><span>FFVars_map_TT</span><span> </span><span>bij_inv_rev</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_TT_cctor</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_inv_bound</span><span> </span><span>FFVars_map_TT</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bij_inv_rev</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>FFVars_intros</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span> </span><span>b</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>disjoint_iff_not_equal</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>bspec</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>imageI</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>bspec</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IImsupp f&quot;</span></span></span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v b&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IImsupp_def</span><span> </span><span>SSupp_def</span><span> </span><span>FFVars_VVr</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>id_on_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FFVars_vvsubst_ge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT&#8658;&#39;a TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp f| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; FFVars t &#10233;  &#8704;x g. |supp g| &lt;o bound(any::&#39;a) &#10230; bij g  &#10230; g a = a &#10230;
    t = map_TT (inv g) (cctor x) &#10230; set2_F x &#8745; IImsupp f = {} &#10230;
    FFVars (f a) &#8838; FFVars (tvsubst f (cctor x))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>FFVars_induct</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>consumes</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isVVr (cctor x)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isVVr_def</span><span> </span><span>tvsubst_VVr</span><span> </span><span>assms</span><span> </span><span>map_TT_VVr</span><span> </span><span>supp_inv_bound</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FFVars_VVr</span><span> </span><span>FFVars_intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>bij_pointE</span><span> </span><span>inv_simp1</span><span> </span><span>singletonD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tvsubst_cctor_not_isVVr</span><span> </span><span>assms</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span> </span><span>supp_inv_bound</span><span> </span><span>TT_inject0</span><span>
</span><span>        </span><span>not_isVVr_set1_F</span><span> </span><span>map_TT_cctor</span><span> </span><span>image_iff</span><span> </span><span>bij_inv_rev</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>set1_F</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>FFVars_intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>fx</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>x</span><span> </span><span>g</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isVVr (cctor x)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>sym</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cctor fx&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>isVVr_def</span><span> </span><span>tvsubst_VVr</span><span> </span><span>FFVars_VVr</span><span> </span><span>UN_iff</span><span> </span><span>bex_simps</span><span> </span><span>assms</span><span> </span><span>map_TT_VVr</span><span>
</span><span>        </span><span>supp_inv_bound</span><span> </span><span>bij_imp_bij_inv</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>VVr_def</span><span> </span><span>TT_inject0</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span> </span><span>&#951;_set3_F</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tvsubst_cctor_not_isVVr</span><span> </span><span>assms</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span> </span><span>supp_inv_bound</span><span> </span><span>imsupp_supp_bound</span><span>
</span><span>        </span><span>TT_inject0</span><span> </span><span>map_TT_cctor</span><span> </span><span>FFVars_map_TT</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>set3_F</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>_</span><span> </span><span>v</span><span> </span><span>u</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fresh_cases</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IImsupp f&quot;</span></span></span><span> </span><span>u</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>IImsupp_SSupp_bound</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>y</span><span> </span><span>g</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bij_inv_rev</span><span> </span><span>map_TT_cctor</span><span> </span><span>supp_id_bound</span><span> </span><span>supp_inv_bound</span><span> </span><span>F_set_map</span><span> </span><span>assms</span><span>
</span><span>            </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>FFVars_intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>fx</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>x</span><span> </span><span>g</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isVVr (cctor x)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>sym</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cctor fx&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>isVVr_def</span><span> </span><span>tvsubst_VVr</span><span> </span><span>FFVars_VVr</span><span> </span><span>UN_iff</span><span> </span><span>bex_simps</span><span> </span><span>assms</span><span> </span><span>map_TT_VVr</span><span>
</span><span>        </span><span>supp_inv_bound</span><span> </span><span>bij_imp_bij_inv</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>VVr_def</span><span> </span><span>TT_inject0</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span> </span><span>&#951;_set4_F</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tvsubst_cctor_not_isVVr</span><span> </span><span>assms</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span> </span><span>supp_inv_bound</span><span> </span><span>imsupp_supp_bound</span><span>
</span><span>        </span><span>TT_inject0</span><span> </span><span>map_TT_cctor</span><span> </span><span>FFVars_map_TT</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>set2_F</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>set4_F</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tvsubst_cctor_not_isVVr</span><span> </span><span>assms</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span> </span><span>supp_inv_bound</span><span> </span><span>imsupp_supp_bound</span><span>
</span><span>        </span><span>TT_inject0</span><span> </span><span>map_TT_cctor</span><span> </span><span>FFVars_map_TT</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>h</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>id_onD</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>h</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h ` _&quot;</span></span></span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;image (inv h)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map_TT h ` _&quot;</span></span></span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;image (map_TT (inv h))&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_image</span><span> </span><span>map_TT_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>map_TT_id</span><span> </span><span>supp_inv_bound</span><span>
</span><span>          </span><span>FFVars_map_TT</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>u</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fresh_cases</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IImsupp f&quot;</span></span></span><span> </span><span>u</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>IImsupp_SSupp_bound</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>y</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec2</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>y</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g o h&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>supp_comp_bound</span><span> </span><span>bij_comp</span><span> </span><span>simp_thms</span><span> </span><span>map_TT_cctor</span><span>
</span><span>              </span><span>o_inv_distrib</span><span> </span><span>supp_inv_bound</span><span> </span><span>bij_imp_bij_inv</span><span> </span><span>o_apply</span><span class="delimiter">[</span><span>of</span><span> </span><span>g</span><span> </span><span>h</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712; set2_F x&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span> </span><span>FFVars_VVr</span><span>
</span><span>              </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>IImsupp_empty_IntD2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set2_F x&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>image_iff</span><span> </span><span>inv_simp1</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>FFVars_intros</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tvsubst f (cctor y)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* fresnness versus vsubst: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>FFVars_tvsubst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT)TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>supp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp f| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FFVars (tvsubst f t) = (&#8899;a1 &#8712; FFVars t. FFVars (f a1))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IImsupp_SSupp_bound</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>supp</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>fresh_cases</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t = cctor x&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_eqI</span><span> </span><span>iffI</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>FFVars_tvsubst_le</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>refl</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>f</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">;</span><span>
</span><span>        </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>supp</span><span> </span><span>imsupp_supp_bound</span><span> </span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>UN_E</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>FFVars_vvsubst_ge</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>f</span><span> </span><span>_</span><span> </span><span>t</span><span> </span><span>id</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>set_mp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>1</span><span> </span><span>supp_id_bound</span><span> </span><span>supp</span><span> </span><span>map_TT_id</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tvsubst_VVr_func</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tvsubst VVr t = t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>TT_existential_coinduct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isVVr t&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>tvsubst_VVr</span><span> </span><span>SSupp_VVr_bound</span><span> </span><span>isVVr_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>VVr_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>F.rel_refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fresh_cases</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IImsupp VVr&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>emp_bound</span><span> </span><span>tvsubst_cctor_not_isVVr</span><span> </span><span>SSupp_VVr_bound</span><span> </span><span>simp_thms</span><span>
</span><span>          </span><span>IImsupp_SSupp_bound</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span>conjI</span><span> </span><span>refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_map</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span> </span><span>id_o</span><span> </span><span>Grp_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>F.rel_refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Monadic composition for substitution functions: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cmp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT &#8658; &#39;a TT) &#8658; (&#39;a &#8658; &#39;a TT) &#8658; &#39;a &#8658; &#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;cmp g f a &#8801; tvsubst g (f a)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isVVr_map</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT &#8658; &#39;a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij f&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp f| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij g&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp g| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isVVr (cctor (map_F f g h i x)) &#10231; isVVr (cctor x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isVVr_def</span><span> </span><span>VVr_def</span><span> </span><span>TT_inject</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>prems</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>u</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv f a&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>id</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>&#951;_set2_F</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>&#951;_set3_F</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>&#951;_set4_F</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span>F_set_map</span><span> </span><span>assms</span><span> </span><span>id_o</span><span> </span><span>inv_o_simp1</span><span>
</span><span>      </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_imp_bij_inv</span><span> </span><span>supp_inv_bound</span><span> </span><span>bij_comp</span><span> </span><span>supp_comp_bound</span><span>
</span><span>      </span><span>vvsubst_id</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>F.map_id</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>trans</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">,</span><span> </span><span>OF</span><span>  </span><span>map_F_&#951;</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv f&quot;</span></span></span><span> </span><span>id</span><span> </span><span>id</span><span> </span><span>id</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span>trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>F.map_id</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>F_map_cong</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>prems</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>u</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f a&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>id</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>&#951;_set2_F</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>&#951;_set3_F</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>&#951;_set4_F</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span>F_set_map</span><span> </span><span>assms</span><span> </span><span>o_id</span><span> </span><span>inv_o_simp1</span><span>
</span><span>      </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_imp_bij_inv</span><span> </span><span>supp_inv_bound</span><span> </span><span>bij_comp</span><span> </span><span>supp_comp_bound</span><span>
</span><span>      </span><span>vvsubst_id</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>F.map_id</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>trans</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">,</span><span> </span><span>OF</span><span>  </span><span>map_F_&#951;</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f&quot;</span></span></span><span> </span><span>id</span><span> </span><span>id</span><span> </span><span>id</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span>F_map_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SSupp_cmp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT) &#8658; &#39;a TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SSupp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp g| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SSupp (cmp g f) &#8838; SSupp g &#8746; SSupp f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SSupp_def</span><span> </span><span>cmp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>tvsubst_VVr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SSupp_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT) &#8658; &#39;a TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SSupp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp g| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SSupp (g o f) &#8838; SSupp g &#8746; supp f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SSupp_def</span><span> </span><span>cmp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>supp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SSupp_cmp_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT) &#8658; &#39;a TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SSupp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp g| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp f| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp (cmp g f)| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span> </span><span>SSupp_cmp</span><span> </span><span>Un_bound</span><span> </span><span>card_of_mono1</span><span> </span><span>ordLeq_ordLess_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IImsupp_cmp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT) &#8658; &#39;a TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SSupp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp g| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IImsupp (cmp g f) &#8838; IImsupp g &#8746; IImsupp f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IImsupp_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SSupp_cmp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>f</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>FFVars_tvsubst</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f _)&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>cmp_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span>
</span><span>      </span><span>FFVars_VVr</span><span> </span><span>SSupp</span><span> </span><span>SSupp_def</span><span> </span><span>cmp_def</span><span> </span><span>empty_iff</span><span> </span><span>insert_iff</span><span> </span><span>mem_Collect_eq</span><span> </span><span>tvsubst_VVr</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Compositionality of tvsubst: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tvsubst_cmp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT)TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SSupp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp g| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp f| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tvsubst (cmp g f) t = tvsubst g (tvsubst f t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>TT_existential_coinduct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isVVr t&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>isVVr_def</span><span> </span><span>tvsubst_VVr</span><span> </span><span>assms</span><span>
</span><span>         </span><span>SSupp_cmp_bound</span><span> </span><span>cmp_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>F.rel_refl_strong</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fresh_cases</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IImsupp (cmp g f) &#8746; IImsupp f &#8746; IImsupp g&quot;</span></span></span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>Un_bound</span><span> </span><span>IImsupp_SSupp_bound</span><span> </span><span>SSupp_cmp_bound</span><span>
</span><span>         </span><span>assms</span><span> </span><span>tvsubst_cctor_not_isVVr</span><span> </span><span>Int_Un_distrib</span><span> </span><span>simp_thms</span><span>
</span><span>         </span><span>F_set_map</span><span> </span><span>image_id</span><span> </span><span>id_apply</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>isVVr_map</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span>conjI</span><span> </span><span>refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_map</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>assms</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span> </span><span>supp_comp_bound</span><span> </span><span>id_o</span><span> </span><span>inv_id</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>F.rel_refl_strong</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>o_apply</span><span> </span><span>Grp_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Obliviousness of tvsubst w.r.t. fresh variables: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tvsubst_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT)TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SSupp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp f| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp g| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; a. a &#8712; FFVars t &#10233; f a = g a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tvsubst f t = tvsubst g t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fr</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>TT_existential_coinduct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isVVr t&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>isVVr_def</span><span> </span><span>FFVars_VVr</span><span> </span><span>insert_iff</span><span> </span><span>empty_iff</span><span> </span><span>simp_thms</span><span> </span><span>tvsubst_VVr</span><span> </span><span>assms</span><span>
</span><span>          </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>F.rel_refl_strong</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fresh_cases</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IImsupp f &#8746; IImsupp g&quot;</span></span></span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>Un_bound</span><span> </span><span>IImsupp_SSupp_bound</span><span> </span><span>assms</span><span> </span><span>tvsubst_cctor_not_isVVr</span><span> </span><span>Int_Un_distrib</span><span> </span><span>simp_thms</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span>conjI</span><span> </span><span>refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_map</span><span> </span><span>F_map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>assms</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span> </span><span>supp_comp_bound</span><span> </span><span>id_o</span><span> </span><span>inv_id</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>F.rel_refl_strong</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>o_apply</span><span> </span><span>id_apply</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>supp_comp_bound</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span>
</span><span>          </span><span>assms</span><span> </span><span>F_set_map</span><span> </span><span>FFVars_simps</span><span> </span><span>relcompp_apply</span><span> </span><span>id_o</span><span> </span><span>Un_iff</span><span> </span><span>UN_iff</span><span> </span><span>imp_disjL</span><span> </span><span>all_conj_distrib</span><span> </span><span>conversep_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>Grp_def</span><span> </span><span>simp_thms</span><span> </span><span>UNIV_I</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI1</span><span> </span><span>exI</span><span> </span><span>conjI</span><span> </span><span>refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>Grp_def</span><span> </span><span>simp_thms</span><span> </span><span>UNIV_I</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI1</span><span> </span><span>exI</span><span> </span><span>conjI</span><span> </span><span>refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>IImsupp_empty_IntD1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tvsubst_cong_id</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT)TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp f| &lt;o bound(any::&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a. a &#8712; FFVars t &#10233; f a = VVr a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tvsubst f t = t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tvsubst_cong</span><span> </span><span>tvsubst_VVr_func</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>SSupp_VVr_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SSupp_upd_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT &#8658; &#39;a TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|SSupp (f (a:=t))| &lt;o bound(any::&#39;a) &#10231; |SSupp f| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SSupp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span> </span><span>singl_bound</span><span> </span><span>ordLeq_refl</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span>
</span><span>    </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ordLeq_ordLess_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>card_of_mono1</span><span> </span><span>ordLess_ordLeq_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Un_bound</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rotated</span><span class="delimiter">]</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">:</span><span> </span><span>card_of_mono1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* vvsubst vs. term-subst specific infrastructure: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>vvsubst_VVr</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT &#8658; &#39;a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp f| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;vvsubst f (VVr a) = VVr (f a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>VVr_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>&#951;_set2_F</span><span> </span><span>&#951;_set3_F</span><span> </span><span>&#951;_set4_F</span><span> </span><span>vvsubst_cctor</span><span> </span><span>map_F_&#951;</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tvsubst_VVr_vvsubst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT)TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|supp f| &lt;o bound(any::&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tvsubst (VVr o f) t = vvsubst f t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>TT_existential_coinduct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;isVVr t&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>tvsubst_VVr</span><span> </span><span>vvsubst_VVr</span><span> </span><span>SSupp_VVr_bound</span><span> </span><span>SSupp_cmp_bound</span><span> </span><span>isVVr_def</span><span> </span><span>f</span><span> </span><span>SSupp_comp_bound</span><span> </span><span>o_apply</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>VVr_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>F.rel_refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fresh_cases</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IImsupp (VVr o f) &#8746; imsupp f&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>emp_bound</span><span> </span><span>tvsubst_cctor_not_isVVr</span><span> </span><span>SSupp_VVr_bound</span><span> </span><span>simp_thms</span><span>
</span><span>          </span><span>imsupp_supp_bound</span><span> </span><span>IImsupp_SSupp_bound</span><span> </span><span>SSupp_comp_bound</span><span> </span><span>f</span><span> </span><span>vvsubst_cctor</span><span> </span><span>Un_bound</span><span> </span><span>Int_Un_distrib</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span>conjI</span><span> </span><span>refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_rel_map</span><span> </span><span>bij_id</span><span> </span><span>supp_id_bound</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>F_rel_mono_strong0</span><span class="delimiter">[</span><span>rotated</span><span> </span><span>6</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>F_rel_map_right</span><span class="delimiter">[</span><span>rotated</span><span> </span><span>6</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>F.rel_refl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(=)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(=)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>                       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>F_set_map</span><span> </span><span>Grp_def</span><span> </span><span>f</span><span> </span><span>supp_id_bound</span><span> </span><span>bij_id</span><span> </span><span>o_apply</span><span> </span><span>id_apply</span><span> </span><span>o_id</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>not_isVVr_set1_F</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Unary substitution: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tusubst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT) &#8658; &#39;a TT &#8658; &#39;a TT &#8658; &#39;a TT&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* a subsituted by s in t  *)</span></span></span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;tusubst a s t &#8801; tvsubst (VVr(a:=s)) t&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The next two are simplification rules working with the variable convention: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tusubst_cctor_not_isVVr</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; isVVr (cctor x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8713; set2_F x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; set2_F x &#8745; FFVars s = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tusubst a s (cctor x) = cctor (map_F id id (tusubst a s) (tusubst a s) x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tusubst_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>tvsubst_cctor_not_isVVr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>SSupp_upd_bound</span><span> </span><span>SSupp_VVr_bound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>  </span><span>fun_upd_apply</span><span> </span><span>IImsupp_def</span><span> </span><span>SSupp_def</span><span>
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tusubst_VVr</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::vvar_TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tusubst a1 s1 (VVr a) = (if a = a1 then s1 else VVr a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tusubst_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tvsubst_VVr</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>SSupp_upd_bound</span><span> </span><span>SSupp_VVr_bound</span><span> </span><span>fun_upd_apply</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>FFVars_tusubst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT)TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;FFVars (tusubst a1 t1 t) = (if a1 &#8712; FFVars t then FFVars t - {a1} &#8746; FFVars t1 else FFVars t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tusubst_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FFVars_tvsubst</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>SSupp_upd_bound</span><span> </span><span>SSupp_VVr_bound</span><span> </span><span>FFVars_VVr</span><span> </span><span>fun_upd_apply</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tusubst_cmp_same</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT)TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tusubst a s2 (tusubst a s1 t) = tusubst a (tusubst a s2 s1) t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tusubst_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tvsubst_cmp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>SSupp_upd_bound</span><span> </span><span>SSupp_VVr_bound</span><span> </span><span>cmp_def</span><span> </span><span>fun_upd_apply</span><span> </span><span>tvsubst_VVr</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>tvsubst_cong</span><span> </span><span>SSupp_cmp_bound</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tusubst_cmp_diff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT)TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a1 &#8800; a2&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a1 &#8713; FFVars s2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tusubst a2 s2 (tusubst a1 s1 t) = tusubst a1 (tusubst a2 s2 s1) (tusubst a2 s2 t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tusubst_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>box_equals</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>tvsubst_cmp</span><span> </span><span>tvsubst_cmp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>SSupp_upd_bound</span><span> </span><span>SSupp_VVr_bound</span><span> </span><span>SSupp_cmp_bound</span><span> </span><span>cmp_def</span><span> </span><span>fun_upd_apply</span><span> </span><span>tvsubst_VVr</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>tvsubst_cong</span><span> </span><span>SSupp_cmp_bound</span><span> </span><span>tvsubst_cong_id</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tusubst_VVr_same</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT)TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tusubst a (VVr a) t = t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tusubst_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>tvsubst_cong_id</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>SSupp_VVr_bound</span><span> </span><span>SSupp_upd_bound</span><span> </span><span>fun_upd_apply</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tusubst_idle</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT)TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8713; FFVars t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tusubst a s t = t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tusubst_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>tvsubst_cong_id</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>SSupp_VVr_bound</span><span> </span><span>SSupp_upd_bound</span><span> </span><span>fun_upd_apply</span><span> </span><span>assms</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* vusubst vs. the term-subst specific infrastructure: *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>vusubst_VVr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;vusubst (a::&#39;a::vvar_TT) (a&#39;::&#39;a::vvar_TT) (VVr a&#39;&#39;) = VVr ((id(a:=a&#39;)) a&#39;&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vusubst_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vvsubst_VVr</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>supp_id_upd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>tusubst_VVr_vusubst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::vvar_TT)TT&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tusubst a (VVr a&#39;) t = vusubst a a&#39; t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tusubst_def</span><span> </span><span>vusubst_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>tvsubst_VVr_vvsubst</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>supp_id_upd</span><span> </span><span>fun_upd_comp</span><span> </span><span>o_id</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
